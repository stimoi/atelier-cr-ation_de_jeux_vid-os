import pygame
import random
import math
import webbrowser
import json
import os

# === Initialisation ===
pygame.init()
screen = pygame.display.set_mode((1366, 769))
clock = pygame.time.Clock()
font = pygame.font.SysFont(None, 48)
small_font = pygame.font.SysFont(None, 32)
title_font = pygame.font.SysFont(None, 96)

# === Constantes ===
SCREEN_WIDTH, SCREEN_HEIGHT = screen.get_size()
GROUND_Y = 680
GRAVITY = 800
JUMP_FORCE = -600
MOVE_SPEED = 300
PROJECTILE_SPEED = 800
FPS = 60
MAX_MONSTERS = 3
MONSTER_SPAWN_COOLDOWN = 2.0
DEATH_BELOW_Y = GROUND_Y + 1500

# === √âtats du jeu ===
MENU = 0
PLAYING = 1
CREDITS = 2
game_state = MENU

# === Cam√©ra ===
camera_offset = pygame.Vector2(0, 0)
CAMERA_LAG = 0.05

# === Couleurs am√©lior√©es ===
SKY_COLOR = (70, 130, 180)
GROUND_COLOR = (34, 139, 34)
PLATFORM_COLOR = (101, 67, 33)
PLATFORM_HIGHLIGHT = (139, 90, 43)
DOOR_COLOR = (184, 134, 11)
DOOR_FRAME = (139, 69, 19)

# === Particules ===
particles = []

def create_particles(pos, color, count=8):
    """Cr√©e des particules d'explosion"""
    for _ in range(count):
        angle = random.uniform(0, 2 * math.pi)
        speed = random.uniform(50, 150)
        particles.append({
            "pos": pygame.Vector2(pos),
            "vel": pygame.Vector2(math.cos(angle) * speed, math.sin(angle) * speed),
            "color": color,
            "life": 1.0
        })

# === Boutons ===
class Button:
    def __init__(self, x, y, width, height, text, color, hover_color):
        self.rect = pygame.Rect(x, y, width, height)
        self.text = text
        self.color = color
        self.hover_color = hover_color
        self.is_hovered = False
    
    def draw(self, surface):
        color = self.hover_color if self.is_hovered else self.color
        pygame.draw.rect(surface, color, self.rect, border_radius=15)
        pygame.draw.rect(surface, (255, 255, 255), self.rect, 3, border_radius=15)
        
        text_surf = font.render(self.text, True, (255, 255, 255))
        text_rect = text_surf.get_rect(center=self.rect.center)
        surface.blit(text_surf, text_rect)
    
    def check_hover(self, pos):
        self.is_hovered = self.rect.collidepoint(pos)
        return self.is_hovered
    
    def is_clicked(self, pos):
        return self.rect.collidepoint(pos)

# Cr√©er les boutons
play_button = Button(SCREEN_WIDTH//2 - 150, SCREEN_HEIGHT//2 - 50, 300, 80, "JOUER", (100, 150, 255), (120, 170, 255))
credits_button = Button(SCREEN_WIDTH//2 - 150, SCREEN_HEIGHT//2 + 60, 300, 80, "CR√âDITS", (255, 150, 100), (255, 170, 120))
back_button = Button(50, SCREEN_HEIGHT - 100, 200, 60, "RETOUR", (200, 100, 100), (220, 120, 120))
website_button = Button(SCREEN_WIDTH//2 - 200, SCREEN_HEIGHT - 150, 400, 70, "üåê Visiter le site", (50, 150, 50), (70, 170, 70))

# === Joueur ===
player_pos = pygame.Vector2(SCREEN_WIDTH / 2, GROUND_Y)
head_radius = 20
body_height = 40
leg_height = 30
arm_length = 25
skin_color = (255, 220, 177)
player_vel_y = 0
direction = 1
walk_cycle = 0

player_pos.y = GROUND_Y - (head_radius + body_height + leg_height)
spawn_point = player_pos.copy()

# === Projectiles ===
projectiles = []
projectile_radius = 6

# === Ennemis ===
monster_radius = 25
monster_spawn_timer = 0.0
initial_monster_positions = []  # Positions initiales depuis le JSON

def spawn_monster_at(x, y, m_type="basic"):
    """Cr√©e un monstre √† une position sp√©cifique avec un type donn√©"""
    is_tank = (m_type == "tank")
    return {
        "pos": pygame.Vector2(x, y),
        "vel_y": 0,
        "dir": random.choice([-1, 1]),
        "is_tank": is_tank,
        "hp": 2 if is_tank else 1,
        "hit_flash": 0.0
    }

def spawn_monster_random():
    """Cr√©e un monstre √† une position al√©atoire (ancien syst√®me)"""
    x = random.randint(100, 2500)
    y = GROUND_Y - monster_radius
    is_tank = random.random() < 0.2
    return {
        "pos": pygame.Vector2(x, y),
        "vel_y": 0,
        "dir": random.choice([-1, 1]),
        "is_tank": is_tank,
        "hp": 2 if is_tank else 1,
        "hit_flash": 0.0
    }

monsters = []

# === Chargement des niveaux depuis level.json ===
def load_levels():
    """Charge les niveaux depuis level.json"""
    levels_dir = os.path.dirname(__file__) if __file__ else "."
    level_path = os.path.join(levels_dir, "level.json")
    
    default_level = {
        "name": "Niveau 1",
        "ground": {"y": 680, "start_x": 0, "end_x": 10000},
        "spawn": {"x": 683, "y": 590},
        "goal": {"x": 2300, "y": -30, "w": 70, "h": 110},
        "platforms": [],
        "enemies": []
    }
    
    if not os.path.isfile(level_path):
        return [default_level]
    
    try:
        with open(level_path, "r", encoding="utf-8") as f:
            data = json.load(f)
            if isinstance(data, dict) and isinstance(data.get("levels"), list) and data["levels"]:
                return data["levels"]
    except Exception as e:
        print(f"Erreur lors du chargement de level.json: {e}")
    
    return [default_level]

levels = load_levels()
selected_level_idx = 0

# === Plateformes ===
platforms = []
goal_rect = pygame.Rect(0, 0, 0, 0)

def apply_level(level):
    """Applique les param√®tres d'un niveau"""
    global GROUND_Y, platforms, goal_rect, spawn_point, initial_monster_positions
    
    # Sol
    ground_data = level.get("ground", {})
    GROUND_Y = int(ground_data.get("y", 680))
    
    # Plateformes
    platforms = [
        pygame.Rect(int(p.get("x", 0)), int(p.get("y", 0)), 
                   int(p.get("w", 100)), int(p.get("h", 20)))
        for p in level.get("platforms", [])
    ]
    
    # Porte/objectif
    goal_data = level.get("goal", {})
    goal_rect.x = int(goal_data.get("x", 2300))
    goal_rect.y = int(goal_data.get("y", -30))
    goal_rect.w = int(goal_data.get("w", 70))
    goal_rect.h = int(goal_data.get("h", 110))
    
    # Spawn du joueur
    spawn_data = level.get("spawn", {})
    spawn_point.update(
        float(spawn_data.get("x", SCREEN_WIDTH / 2)),
        float(spawn_data.get("y", GROUND_Y - (head_radius + body_height + leg_height)))
    )
    
    # Positions initiales des ennemis
    initial_monster_positions = []
    for enemy in level.get("enemies", []):
        initial_monster_positions.append({
            "x": int(enemy.get("x", 200)),
            "y": int(enemy.get("y", GROUND_Y - monster_radius)),
            "type": enemy.get("type", "basic")
        })

# Appliquer le niveau initial
apply_level(levels[selected_level_idx])

# === Score, Vies, Victoire ===
score = 0
lives = 3
invuln_time = 1.5
invuln_timer = 0.0
is_invulnerable = False
victory = False

def reset_game():
    """R√©initialise le jeu"""
    global player_pos, player_vel_y, score, lives, victory, camera_offset, monsters
    global projectiles, particles, monster_spawn_timer, is_invulnerable, invuln_timer
    
    player_pos = spawn_point.copy()
    player_vel_y = 0
    score = 0
    lives = 3
    victory = False
    camera_offset = pygame.Vector2(0, 0)
    
    # Cr√©er les monstres aux positions initiales du niveau
    monsters = []
    for pos_data in initial_monster_positions:
        monsters.append(spawn_monster_at(pos_data["x"], pos_data["y"], pos_data["type"]))
    
    projectiles = []
    particles = []
    monster_spawn_timer = 0
    is_invulnerable = False
    invuln_timer = 0

def draw_menu():
    """Dessine le menu principal"""
    # Fond d√©grad√© anim√©
    for i in range(SCREEN_HEIGHT):
        color = (
            int(70 + 30 * math.sin(i * 0.01 + pygame.time.get_ticks() * 0.001)),
            int(130 + 50 * math.cos(i * 0.015 + pygame.time.get_ticks() * 0.001)),
            int(180 + 50 * math.sin(i * 0.02 + pygame.time.get_ticks() * 0.001))
        )
        pygame.draw.line(screen, color, (0, i), (SCREEN_WIDTH, i))
    
    # Titre
    title_text = title_font.render("JEU DE PLATEFORME", True, (255, 255, 255))
    title_shadow = title_font.render("JEU DE PLATEFORME", True, (0, 0, 0))
    screen.blit(title_shadow, (SCREEN_WIDTH//2 - title_text.get_width()//2 + 4, 104))
    screen.blit(title_text, (SCREEN_WIDTH//2 - title_text.get_width()//2, 100))
    
    # Sous-titre
    subtitle = font.render("Les Mardis de l'Engagement", True, (255, 215, 0))
    screen.blit(subtitle, (SCREEN_WIDTH//2 - subtitle.get_width()//2, 200))
    
    # Boutons
    mouse_pos = pygame.mouse.get_pos()
    play_button.check_hover(mouse_pos)
    credits_button.check_hover(mouse_pos)
    play_button.draw(screen)
    credits_button.draw(screen)
    
    # Instructions
    info_text = small_font.render("D√©placements: Q/D ou Fl√®ches | Saut: ESPACE | Tir: Clic Souris", True, (255, 255, 255))
    screen.blit(info_text, (SCREEN_WIDTH//2 - info_text.get_width()//2, SCREEN_HEIGHT - 50))

def draw_credits():
    """Dessine l'√©cran des cr√©dits"""
    # Fond
    for i in range(SCREEN_HEIGHT):
        color = (
            int(50 + 20 * math.sin(i * 0.01)),
            int(80 + 30 * math.cos(i * 0.015)),
            int(120 + 40 * math.sin(i * 0.02))
        )
        pygame.draw.line(screen, color, (0, i), (SCREEN_WIDTH, i))
    
    # Titre
    title = title_font.render("CR√âDITS", True, (255, 215, 0))
    screen.blit(title, (SCREEN_WIDTH//2 - title.get_width()//2, 50))
    
    # Cadre de cr√©dits
    credits_box = pygame.Rect(SCREEN_WIDTH//2 - 400, 180, 800, 400)
    pygame.draw.rect(screen, (255, 255, 255, 30), credits_box, border_radius=20)
    pygame.draw.rect(screen, (255, 215, 0), credits_box, 3, border_radius=20)
    
    # Texte des cr√©dits
    y_offset = 220
    credits_title = font.render("D√©velopp√© par:", True, (255, 255, 255))
    screen.blit(credits_title, (SCREEN_WIDTH//2 - credits_title.get_width()//2, y_offset))
    
    y_offset += 60
    team_members = ["Antoine", "Isaac", "L√©o", "Mathis", "Samuel"]
    for i, member in enumerate(team_members):
        color = [
            (255, 100, 100),
            (100, 255, 100),
            (100, 100, 255),
            (255, 255, 100),
            (255, 100, 255)
        ][i]
        member_text = font.render(f"‚Ä¢ {member}", True, color)
        screen.blit(member_text, (SCREEN_WIDTH//2 - member_text.get_width()//2, y_offset))
        y_offset += 50
    
    # Projet
    y_offset += 20
    project_text = small_font.render("Projet: Les Mardis de l'Engagement", True, (200, 200, 200))
    screen.blit(project_text, (SCREEN_WIDTH//2 - project_text.get_width()//2, y_offset))
    
    y_offset += 40
    tech_text = small_font.render("Cr√©√© avec Python & Pygame", True, (200, 200, 200))
    screen.blit(tech_text, (SCREEN_WIDTH//2 - tech_text.get_width()//2, y_offset))
    
    # Boutons
    mouse_pos = pygame.mouse.get_pos()
    website_button.check_hover(mouse_pos)
    back_button.check_hover(mouse_pos)
    website_button.draw(screen)
    back_button.draw(screen)

# === Boucle principale ===
running = True
dt = 0

while running:
    mouse_pos = pygame.mouse.get_pos()
    
    # √âv√©nements
    for event in pygame.event.get():
        if event.type == pygame.QUIT or (
            event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
            running = False
        
        elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if game_state == MENU:
                if play_button.is_clicked(mouse_pos):
                    game_state = PLAYING
                    reset_game()
                elif credits_button.is_clicked(mouse_pos):
                    game_state = CREDITS
            
            elif game_state == CREDITS:
                if back_button.is_clicked(mouse_pos):
                    game_state = MENU
                elif website_button.is_clicked(mouse_pos):
                    webbrowser.open('http://zyrahost.fr/mardi')
            
            elif game_state == PLAYING and not victory:
                # Tir vers la souris
                mouse_world_x = mouse_pos[0] + camera_offset.x
                mouse_world_y = mouse_pos[1] + camera_offset.y
                
                dx = mouse_world_x - player_pos.x
                dy = mouse_world_y - player_pos.y
                distance = math.sqrt(dx**2 + dy**2)
                
                if distance > 0:
                    dir_x = dx / distance
                    dir_y = dy / distance
                    
                    proj_x = player_pos.x + dir_x * (head_radius + 10)
                    proj_y = player_pos.y + dir_y * (head_radius + 10)
                    
                    projectiles.append({
                        "pos": pygame.Vector2(proj_x, proj_y),
                        "vel": pygame.Vector2(dir_x * PROJECTILE_SPEED, dir_y * PROJECTILE_SPEED)
                    })

    # --- AFFICHAGE SELON L'√âTAT ---
    if game_state == MENU:
        draw_menu()
    
    elif game_state == CREDITS:
        draw_credits()
    
    elif game_state == PLAYING:
        # --- LOGIQUE DU JEU ---
        
        # Mouvements
        keys = pygame.key.get_pressed()
        moving = False
        if keys[pygame.K_q] or keys[pygame.K_LEFT]:
            player_pos.x -= MOVE_SPEED * dt
            direction = -1
            moving = True
        if keys[pygame.K_d] or keys[pygame.K_RIGHT]:
            player_pos.x += MOVE_SPEED * dt
            direction = 1
            moving = True
        if moving:
            walk_cycle += 10 * dt
        else:
            walk_cycle = 0

        # D√©tection sol/plateforme joueur
        feet_y = player_pos.y + head_radius + body_height + leg_height
        on_ground = False
        if feet_y >= GROUND_Y - 0.1:
            on_ground = True
        else:
            for plat in platforms:
                if plat.left - 5 < player_pos.x < plat.right + 5 and abs(feet_y - plat.top) <= 6:
                    on_ground = True
                    player_pos.y = plat.top - (head_radius + body_height + leg_height)
                    player_vel_y = 0
                    break

        if keys[pygame.K_SPACE] and on_ground:
            player_vel_y = JUMP_FORCE

        player_vel_y += GRAVITY * dt
        player_pos.y += player_vel_y * dt

        feet_y = player_pos.y + head_radius + body_height + leg_height
        if feet_y > GROUND_Y:
            player_pos.y = GROUND_Y - (head_radius + body_height + leg_height)
            player_vel_y = 0

        player_rect = pygame.Rect(int(player_pos.x - head_radius), int(player_pos.y - head_radius), 
                                  head_radius*2, head_radius*2 + body_height + leg_height)
        if player_vel_y >= 0:
            for plat in platforms:
                if player_rect.colliderect(plat):
                    plat_top = plat.top
                    if feet_y - player_vel_y * dt <= plat_top:
                        player_pos.y = plat_top - (head_radius + body_height + leg_height)
                        player_vel_y = 0
                        break

        player_pos.x = max(head_radius, player_pos.x)

        if player_pos.y > DEATH_BELOW_Y:
            lives -= 1
            is_invulnerable = True
            invuln_timer = invuln_time
            player_pos = spawn_point.copy()
            player_vel_y = 0
            create_particles(player_pos, (255, 100, 100), 15)

        # Cam√©ra
        target_x = player_pos.x - SCREEN_WIDTH // 2
        target_y = player_pos.y - SCREEN_HEIGHT // 2
        camera_offset.x += (target_x - camera_offset.x) * CAMERA_LAG
        camera_offset.y += (target_y - camera_offset.y) * CAMERA_LAG

        # Projectiles
        for proj in projectiles[:]:
            proj["pos"] += proj["vel"] * dt
            if (proj["pos"].x < camera_offset.x - 200 or proj["pos"].x > camera_offset.x + SCREEN_WIDTH + 200 or
                proj["pos"].y < camera_offset.y - 200 or proj["pos"].y > camera_offset.y + SCREEN_HEIGHT + 200):
                projectiles.remove(proj)

        # Collision projectile-monstre
        for proj in projectiles[:]:
            for monster in monsters[:]:
                if proj["pos"].distance_to(monster["pos"]) < projectile_radius + monster_radius:
                    monster["hp"] -= 1
                    monster["hit_flash"] = 0.2
                    
                    if monster["hp"] <= 0:
                        create_particles(monster["pos"], (255, 50, 50), 12)
                        monsters.remove(monster)
                        score += 2 if monster["is_tank"] else 1
                    
                    if proj in projectiles:
                        projectiles.remove(proj)
                    break

        # Spawn avec cooldown (respawn al√©atoire apr√®s les monstres initiaux)
        monster_spawn_timer -= dt
        if monster_spawn_timer <= 0 and len(monsters) < MAX_MONSTERS:
            monsters.append(spawn_monster_random())
            monster_spawn_timer = MONSTER_SPAWN_COOLDOWN

        # Monstres (mouvement, gravit√© et flash)
        for monster in monsters:
            # Mouvement horizontal
            monster["pos"].x += monster["dir"] * 80 * dt
            if monster["pos"].x < 50:
                monster["dir"] = 1
            if monster["pos"].x > 2500:
                monster["dir"] = -1
            
            # Gravit√© des monstres
            monster["vel_y"] += GRAVITY * dt
            monster["pos"].y += monster["vel_y"] * dt
            
            # Collision avec le sol
            monster_feet_y = monster["pos"].y + monster_radius
            if monster_feet_y > GROUND_Y:
                monster["pos"].y = GROUND_Y - monster_radius
                monster["vel_y"] = 0
            
            # Collision avec les plateformes
            if monster["vel_y"] >= 0:
                for plat in platforms:
                    if (plat.left - monster_radius < monster["pos"].x < plat.right + monster_radius and
                        abs(monster_feet_y - plat.top) <= 10):
                        monster["pos"].y = plat.top - monster_radius
                        monster["vel_y"] = 0
                        break
            
            if monster["hit_flash"] > 0:
                monster["hit_flash"] -= dt

        # Collision joueur-ennemi
        p_center = (int(player_pos.x), int(player_pos.y))
        if not is_invulnerable:
            for monster in monsters[:]:
                if pygame.Vector2(p_center).distance_to(monster["pos"]) < head_radius + monster_radius:
                    lives -= 1
                    is_invulnerable = True
                    invuln_timer = invuln_time
                    player_pos = spawn_point.copy()
                    player_vel_y = 0
                    create_particles(player_pos, (255, 255, 100), 15)
                    break

        if is_invulnerable:
            invuln_timer -= dt
            if invuln_timer <= 0:
                is_invulnerable = False

        # Particules
        for part in particles[:]:
            part["pos"] += part["vel"] * dt
            part["vel"].y += GRAVITY * 0.5 * dt
            part["life"] -= dt * 2
            if part["life"] <= 0:
                particles.remove(part)

        # Victoire
        if not victory and pygame.Rect(int(player_pos.x - head_radius), int(player_pos.y - head_radius), 
                                       head_radius*2, head_radius*2).colliderect(goal_rect):
            victory = True

        # --- DESSIN DU JEU ---

        # Ciel d√©grad√©
        for i in range(SCREEN_HEIGHT):
            color = (
                int(70 + (130 - 70) * i / SCREEN_HEIGHT),
                int(130 + (180 - 130) * i / SCREEN_HEIGHT),
                int(180 + (230 - 180) * i / SCREEN_HEIGHT)
            )
            pygame.draw.line(screen, color, (0, i), (SCREEN_WIDTH, i))

        # Sol
        ground_rect = pygame.Rect(0 - camera_offset.x, GROUND_Y - camera_offset.y, 3000, 100)
        pygame.draw.rect(screen, GROUND_COLOR, ground_rect)
        pygame.draw.rect(screen, (25, 100, 25), ground_rect, 3)
        for i in range(0, 3000, 50):
            pygame.draw.line(screen, (44, 160, 44), 
                            (i - camera_offset.x, GROUND_Y - camera_offset.y),
                            (i - camera_offset.x, GROUND_Y - camera_offset.y + 100), 2)

        # Plateformes
        for plat in platforms:
            plat_rect_screen = plat.move(-camera_offset.x, -camera_offset.y)
            pygame.draw.rect(screen, PLATFORM_COLOR, plat_rect_screen)
            pygame.draw.rect(screen, PLATFORM_HIGHLIGHT, plat_rect_screen, 3)
            pygame.draw.line(screen, (80, 50, 20), 
                            (plat_rect_screen.left, plat_rect_screen.top + 5),
                            (plat_rect_screen.right, plat_rect_screen.top + 5), 2)

        # Porte
        goal_rect_screen = goal_rect.move(-camera_offset.x, -camera_offset.y)
        pygame.draw.rect(screen, DOOR_COLOR, goal_rect_screen)
        pygame.draw.rect(screen, DOOR_FRAME, goal_rect_screen, 5)
        pygame.draw.line(screen, (100, 70, 20), 
                        (goal_rect_screen.centerx, goal_rect_screen.top),
                        (goal_rect_screen.centerx, goal_rect_screen.bottom), 3)
        knob_pos = (goal_rect_screen.right - 12, goal_rect_screen.centery)
        pygame.draw.circle(screen, (30, 30, 30), knob_pos, 6)
        pygame.draw.circle(screen, (80, 80, 80), knob_pos, 3)

        # Joueur
        p_center_screen = (int(player_pos.x - camera_offset.x), int(player_pos.y - camera_offset.y))

        if not is_invulnerable or int(invuln_timer * 10) % 2 == 0:
            pygame.draw.circle(screen, skin_color, p_center_screen, head_radius)
            pygame.draw.circle(screen, (0, 0, 0), p_center_screen, head_radius, 3)
            
            eye_offset = 7
            pygame.draw.circle(screen, (0, 0, 0), 
                              (p_center_screen[0] - eye_offset * direction, p_center_screen[1] - 5), 3)
            pygame.draw.arc(screen, (0, 0, 0), 
                           (p_center_screen[0] - head_radius, p_center_screen[1] - head_radius, 
                            head_radius*2, head_radius*2), 3.8, 5.0, 3)

            body_start = (p_center_screen[0], p_center_screen[1] + head_radius)
            body_end = (p_center_screen[0], p_center_screen[1] + head_radius + body_height)
            pygame.draw.line(screen, (0, 0, 0), body_start, body_end, 5)

            arm_y = p_center_screen[1] + head_radius + 15
            arm_angle = math.sin(walk_cycle * 10) * 15
            arm_offset = arm_length * math.cos(math.radians(arm_angle))
            pygame.draw.line(screen, (0, 0, 0), 
                            (p_center_screen[0] - arm_offset, arm_y), 
                            (p_center_screen[0] + arm_offset, arm_y), 5)

            leg_offset = 15
            leg_swing = math.sin(walk_cycle * 10) * 12
            leg_left = (p_center_screen[0] - leg_offset, body_end[1] + leg_height + leg_swing)
            leg_right = (p_center_screen[0] + leg_offset, body_end[1] + leg_height - leg_swing)
            pygame.draw.line(screen, (0, 0, 0), body_end, leg_left, 5)
            pygame.draw.line(screen, (0, 0, 0), body_end, leg_right, 5)

        # Projectiles
        for proj in projectiles:
            proj_screen = (int(proj["pos"].x - camera_offset.x), int(proj["pos"].y - camera_offset.y))
            pygame.draw.circle(screen, (150, 255, 150), proj_screen, projectile_radius + 2)
            pygame.draw.circle(screen, (0, 255, 0), proj_screen, projectile_radius)
            pygame.draw.circle(screen, (255, 255, 255), proj_screen, projectile_radius - 3)

        # Monstres
        for monster in monsters:
            monster_screen = (int(monster["pos"].x - camera_offset.x), 
                             int(monster["pos"].y - camera_offset.y))
            
            monster_color = (255, 200, 200) if monster["hit_flash"] > 0 else (220, 20, 20)
            
            if monster["is_tank"]:
                pygame.draw.circle(screen, monster_color, monster_screen, monster_radius + 5)
                pygame.draw.circle(screen, (0, 0, 0), monster_screen, monster_radius + 5, 3)
                
                backpack_x = monster_screen[0] - 15
                backpack_y = monster_screen[1]
                backpack_rect = pygame.Rect(backpack_x - 10, backpack_y - 15, 20, 30)
                pygame.draw.rect(screen, (60, 40, 20), backpack_rect)
                pygame.draw.rect(screen, (0, 0, 0), backpack_rect, 2)
                pygame.draw.circle(screen, (100, 80, 50), (backpack_x, backpack_y - 5), 5)
                
                pygame.draw.circle(screen, (255, 255, 0), (monster_screen[0] - 8, monster_screen[1] - 5), 4)
                pygame.draw.circle(screen, (255, 255, 0), (monster_screen[0] + 8, monster_screen[1] - 5), 4)
                pygame.draw.circle(screen, (0, 0, 0), (monster_screen[0] - 8, monster_screen[1] - 5), 2)
                pygame.draw.circle(screen, (0, 0, 0), (monster_screen[0] + 8, monster_screen[1] - 5), 2)
                
                if monster["hp"] == 2:
                    pygame.draw.circle(screen, (0, 255, 0), (monster_screen[0], monster_screen[1] - 40), 5)
                    pygame.draw.circle(screen, (0, 255, 0), (monster_screen[0] + 12, monster_screen[1] - 40), 5)
                else:
                    pygame.draw.circle(screen, (255, 165, 0), (monster_screen[0], monster_screen[1] - 40), 5)
            else:
                pygame.draw.circle(screen, monster_color, monster_screen, monster_radius)
                pygame.draw.circle(screen, (0, 0, 0), monster_screen, monster_radius, 3)
                
                pygame.draw.circle(screen, (0, 0, 0), (monster_screen[0] - 8, monster_screen[1] - 5), 4)
                pygame.draw.circle(screen, (0, 0, 0), (monster_screen[0] + 8, monster_screen[1] - 5), 4)

        # Particules
        for part in particles:
            if part["life"] > 0:
                part_screen = (int(part["pos"].x - camera_offset.x), int(part["pos"].y - camera_offset.y))
                color = tuple(min(255, max(0, int(c * part["life"]))) for c in part["color"])
                pygame.draw.circle(screen, color, part_screen, 3)

        # --- HUD ---
        hud_panel = pygame.Surface((300, 150), pygame.SRCALPHA)
        hud_panel.fill((0, 0, 0, 120))
        screen.blit(hud_panel, (10, 10))

        score_text = font.render(f"Score: {score}", True, (255, 255, 255))
        screen.blit(score_text, (30, 25))
        
        # Vies avec c≈ìurs
        lives_text = font.render("Vies:", True, (255, 255, 255))
        screen.blit(lives_text, (30, 70))
        for i in range(lives):
            heart_x = 130 + i * 35
            pygame.draw.circle(screen, (255, 50, 50), (heart_x - 5, 85), 10)
            pygame.draw.circle(screen, (255, 50, 50), (heart_x + 5, 85), 10)
            pygame.draw.polygon(screen, (255, 50, 50), 
                               [(heart_x - 15, 85), (heart_x, 100), (heart_x + 15, 85)])

        if is_invulnerable:
            inv_text = small_font.render("‚ö° INVULN√âRABLE", True, (255, 255, 0))
            screen.blit(inv_text, (30, 120))

        # Indicateur de cooldown spawn
        if monster_spawn_timer > 0:
            cooldown_text = small_font.render(f"Prochain spawn: {monster_spawn_timer:.1f}s", 
                                             True, (200, 200, 200))
            screen.blit(cooldown_text, (SCREEN_WIDTH - 350, 30))

        # Messages de fin
        if victory:
            overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
            overlay.fill((0, 0, 0, 180))
            screen.blit(overlay, (0, 0))
            
            big_text = pygame.font.SysFont(None, 120).render("VICTOIRE !", True, (255, 215, 0))
            sub_text = font.render("F√©licitations !", True, (255, 255, 255))
            score_final = font.render(f"Score Final: {score}", True, (255, 255, 255))
            
            screen.blit(big_text, (SCREEN_WIDTH//2 - big_text.get_width()//2, SCREEN_HEIGHT//2 - 100))
            screen.blit(sub_text, (SCREEN_WIDTH//2 - sub_text.get_width()//2, SCREEN_HEIGHT//2 + 20))
            screen.blit(score_final, (SCREEN_WIDTH//2 - score_final.get_width()//2, SCREEN_HEIGHT//2 + 70))
            pygame.display.flip()
            pygame.time.delay(3000)
            running = False

        if lives <= 0:
            overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
            overlay.fill((0, 0, 0, 200))
            screen.blit(overlay, (0, 0))
            
            over_text = pygame.font.SysFont(None, 96).render("GAME OVER", True, (255, 50, 50))
            score_final = font.render(f"Score: {score}", True, (255, 255, 255))
            
            screen.blit(over_text, (SCREEN_WIDTH//2 - over_text.get_width()//2, SCREEN_HEIGHT//2 - 60))
            screen.blit(score_final, (SCREEN_WIDTH//2 - score_final.get_width()//2, SCREEN_HEIGHT//2 + 20))
            pygame.display.flip()
            pygame.time.delay(2000)
            
            lives = 3
            score = 0
            player_pos = spawn_point.copy()
            player_vel_y = 0
            camera_offset = pygame.Vector2(0, 0)
            
            # Recr√©er les monstres aux positions initiales
            monsters = []
            for pos_data in initial_monster_positions:
                monsters.append(spawn_monster_at(pos_data["x"], pos_data["y"], pos_data["type"]))
            
            projectiles = []
            particles = []

    pygame.display.flip()
    dt = clock.tick(FPS) / 1000

pygame.quit()
