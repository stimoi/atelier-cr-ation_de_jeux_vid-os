<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Éditeur de niveaux</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 0; display: grid; grid-template-columns: 360px 1fr; height: 100vh; }
    header { grid-column: 1 / -1; padding: 10px 16px; background: #222; color: #fff; display: flex; align-items: center; gap: 8px; }
    header h1 { font-size: 18px; margin: 0; }
    .sidebar { overflow: auto; border-right: 1px solid #ddd; padding: 12px; display: flex; flex-direction: column; gap: 16px; }
    .section { border: 1px solid #ddd; border-radius: 8px; padding: 10px; }
    .section h2 { margin: 0 0 8px 0; font-size: 16px; }
    label { display: block; font-size: 12px; color: #333; margin-top: 8px; }
    input[type="number"], input[type="text"] { width: 100%; box-sizing: border-box; padding: 6px 8px; margin-top: 4px; }
    button { padding: 6px 10px; border-radius: 6px; border: 1px solid #ccc; background: #f7f7f7; cursor: pointer; }
    button.primary { background: #2563eb; color: white; border-color: #2563eb; }
    button.danger { background: #dc2626; color: white; border-color: #dc2626; }
    .row { display: flex; gap: 8px; align-items: center; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .platforms { display: flex; flex-direction: column; gap: 8px; max-height: 240px; overflow: auto; }
    .platform { display: grid; grid-template-columns: repeat(4, 1fr) 32px; gap: 6px; border-bottom: 1px solid #ddd; }
    .canvas-wrap { position: relative; height: calc(100vh - 60px); background: #eef6ff; }
    canvas { width: 100%; height: 100%; display: block; background: linear-gradient(180deg, #7db3e8 0%, #cfe9ff 100%); }
    .toolbar { position: absolute; top: 12px; left: 12px; display: flex; gap: 8px; background: rgba(255,255,255,0.9); padding: 8px 10px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,.08); }
    small.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color: #555; }
    .tag { padding: 2px 6px; border-radius: 999px; font-size: 11px; border: 1px solid #ddd; }
    .tag.enemy { background: #fee2e2; color: #991b1b; border-color: #fecaca; }
    .list-headers { display: grid; gap: 6px; font-size: 12px; color: #555; padding: 0 2px; }
    .list-headers.platform { grid-template-columns: repeat(4, 1fr) 32px; }
    .list-headers.enemy { grid-template-columns: repeat(4, 1fr) 1fr 32px; }
    .list-headers span { font-weight: 600; }
    .enemy-type { display: inline-block; width: 60px; }
    .enemy-type.basic { background: #fee2e2; color: #991b1b; border-color: #fecaca; }
    .enemy-type.patrol { background: #f7d2c4; color: #7a3e1c; border-color: #ffd7be; }
    .enemy-type.shooter { background: #c4f7d2; color: #1c7a3e; border-color: #bef7d7; }
    .enemy-type.flyer { background: #d2c4f7; color: #3e1c7a; border-color: #d7bef7; }
  </style>
</head>
<body>
  <header>
    <h1>Éditeur de niveaux</h1>
    <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
      <input type="file" id="importFile" accept="application/json" />
      <button class="primary" id="exportBtn">Exporter levels.json</button>
    </div>
  </header>

  <div class="sidebar">
    <div class="section">
      <h2>Niveaux</h2>
      <div class="row">
        <select id="levelSelect" style="flex:1"></select>
        <button id="addLevelBtn">Ajouter</button>
        <button class="danger" id="deleteLevelBtn">Supprimer</button>
      </div>
      <label>Nom</label>
      <input type="text" id="levelName" placeholder="Nom du niveau" />
    </div>

    <div class="section">
      <h2>Sol</h2>
      <div class="grid-2">
        <div>
          <label>Y</label>
          <input type="number" id="groundY" />
        </div>
        <div>
          <label>Début X</label>
          <input type="number" id="groundStart" />
        </div>
        <div>
          <label>Fin X</label>
          <input type="number" id="groundEnd" />
        </div>
      </div>
    </div>

    <div class="section">
      <h2>Spawn</h2>
      <div class="grid-2">
        <div>
          <label>X</label>
          <input type="number" id="spawnX" />
        </div>
        <div>
          <label>Y</label>
          <input type="number" id="spawnY" />
        </div>
      </div>
      <label>Position de départ</label>
    </div>

    <div class="section">
      <h2>But (porte)</h2>
      <div class="grid-2">
        <div>
          <label>X</label>
          <input type="number" id="goalX" />
        </div>
        <div>
          <label>Y</label>
          <input type="number" id="goalY" />
        </div>
        <div>
          <label>Largeur</label>
          <input type="number" id="goalW" />
        </div>
        <div>
          <label>Hauteur</label>
          <input type="number" id="goalH" />
        </div>
      </div>
      <label>Position de la porte</label>
    </div>

    <div class="section">
      <h2>Plateformes</h2>
      <div class="list-headers platform">
        <span>X</span>
        <span>Y</span>
        <span>Largeur</span>
        <span>Hauteur</span>
        <span></span>
      </div>
      <div class="platforms" id="platformList"></div>
      <button id="addPlatformBtn">+ Ajouter une plateforme</button>
      <small class="mono">Astuce: cliquez dans la prévisualisation pour ajouter rapidement (100x20).</small>
    </div>

    <div class="section">
      <h2>Ennemis <span class="tag enemy">danger</span></h2>
      <div class="list-headers enemy">
        <span>X</span>
        <span>Y</span>
        <span>Largeur</span>
        <span>Hauteur</span>
        <span>Type</span>
        <span></span>
      </div>
      <div class="platforms" id="enemyList"></div>
      <button id="addEnemyBtn">+ Ajouter un ennemi</button>
      <small class="mono">Conseil: placez-les au-dessus du sol et des plateformes.</small>
    </div>
  </div>

  <div class="canvas-wrap">
    <div class="toolbar">
      <small class="mono">Aperçu. Défilement horizontal: molette + Shift.</small>
      <small class="mono">Zoom: Ctrl + molette.</small>
      <small class="mono" id="mouseInfo"></small>
      <label class="mono" style="display:flex;align-items:center;gap:6px;margin-left:8px;">
        <input type="checkbox" id="snapToggle" checked>
        Snap
      </label>
      <label class="mono" style="display:flex;align-items:center;gap:6px;">
        Pas
        <input type="number" id="snapStep" value="10" min="1" style="width:64px;">
      </label>
    </div>
    <canvas id="view"></canvas>
  </div>

  <script>
    const DEFAULT_LEVEL = {
      name: 'Niveau 1',
      ground: { y: 680, start_x: 0, end_x: 3000 },
      spawn: { x: 683, y: 590 },
      goal: { x: 2300, y: -30, w: 70, h: 110 },
      platforms: [
        { x: 100, y: 560, w: 200, h: 20 },
        { x: 380, y: 480, w: 180, h: 20 },
        { x: 620, y: 420, w: 160, h: 20 },
        { x: 860, y: 360, w: 140, h: 20 },
        { x: 1060, y: 300, w: 180, h: 20 },
        { x: 1300, y: 200, w: 250, h: 20 },
        { x: 1600, y: 600, w: 100, h: 20 },
        { x: 1750, y: 500, w: 100, h: 20 },
        { x: 1600, y: 400, w: 100, h: 20 },
        { x: 1750, y: 300, w: 100, h: 20 },
        { x: 1600, y: 200, w: 100, h: 20 },
        { x: 1750, y: 100, w: 100, h: 20 },
        { x: 1900, y: 60,  w: 500, h: 20 }
      ],
      enemies: [
        { x: 500, y: 640, w: 28, h: 28, type: 'basic' },
      ]
    };

    let data = { levels: [ structuredClone(DEFAULT_LEVEL) ] };
    let current = 0;

    const els = {
      levelSelect: document.getElementById('levelSelect'),
      levelName: document.getElementById('levelName'),
      groundY: document.getElementById('groundY'),
      groundStart: document.getElementById('groundStart'),
      groundEnd: document.getElementById('groundEnd'),
      spawnX: document.getElementById('spawnX'),
      spawnY: document.getElementById('spawnY'),
      goalX: document.getElementById('goalX'),
      goalY: document.getElementById('goalY'),
      goalW: document.getElementById('goalW'),
      goalH: document.getElementById('goalH'),
      platformList: document.getElementById('platformList'),
      enemyList: document.getElementById('enemyList'),
      addPlatformBtn: document.getElementById('addPlatformBtn'),
      addEnemyBtn: document.getElementById('addEnemyBtn'),
      addLevelBtn: document.getElementById('addLevelBtn'),
      deleteLevelBtn: document.getElementById('deleteLevelBtn'),
      exportBtn: document.getElementById('exportBtn'),
      importFile: document.getElementById('importFile'),
      view: document.getElementById('view')
    };

    function refreshLevelSelect() {
      els.levelSelect.innerHTML = '';
      data.levels.forEach((lvl, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = `${i+1}. ${lvl.name || 'Sans nom'}`;
        els.levelSelect.appendChild(opt);
      });
      els.levelSelect.value = String(current);
    }

    function bindValue(input, getter, setter) {
      input.value = getter();
      input.oninput = () => { setter(Number.isFinite(+input.value) ? +input.value : input.value); draw(); };
    }

    function renderForm() {
      const lvl = data.levels[current];
      els.levelName.value = lvl.name || '';
      bindValue(els.groundY, () => lvl.ground.y, v => lvl.ground.y = v);
      bindValue(els.groundStart, () => lvl.ground.start_x, v => lvl.ground.start_x = v);
      bindValue(els.groundEnd, () => lvl.ground.end_x, v => lvl.ground.end_x = v);
      bindValue(els.spawnX, () => lvl.spawn.x, v => lvl.spawn.x = v);
      bindValue(els.spawnY, () => lvl.spawn.y, v => lvl.spawn.y = v);
      bindValue(els.goalX, () => lvl.goal.x, v => lvl.goal.x = v);
      bindValue(els.goalY, () => lvl.goal.y, v => lvl.goal.y = v);
      bindValue(els.goalW, () => lvl.goal.w, v => lvl.goal.w = v);
      bindValue(els.goalH, () => lvl.goal.h, v => lvl.goal.h = v);

      els.levelName.oninput = () => { lvl.name = els.levelName.value; refreshLevelSelect(); };

      els.platformList.innerHTML = '';
      lvl.platforms.forEach((p, idx) => {
        const row = document.createElement('div');
        row.className = 'platform';
        row.innerHTML = `
          <input type="number" value="${p.x}" />
          <input type="number" value="${p.y}" />
          <input type="number" value="${p.w}" />
          <input type="number" value="${p.h}" />
          <button data-idx="${idx}">Ã—</button>
        `;
        const [x,y,w,h,btn] = row.querySelectorAll('input,button');
        x.oninput = () => { p.x = +x.value; draw(); };
        y.oninput = () => { p.y = +y.value; draw(); };
        w.oninput = () => { p.w = +w.value; draw(); };
        h.oninput = () => { p.h = +h.value; draw(); };
        btn.onclick = () => { lvl.platforms.splice(idx,1); renderForm(); draw(); };
        els.platformList.appendChild(row);
      });

      els.enemyList.innerHTML = '';
      (lvl.enemies || (lvl.enemies = [])).forEach((en, idx) => {
        const row = document.createElement('div');
        row.className = 'platform';
        row.style.gridTemplateColumns = 'repeat(4, 1fr) 1fr 32px';
        row.innerHTML = `
          <input type="number" value="${en.x}" />
          <input type="number" value="${en.y}" />
          <input type="number" value="${en.w}" />
          <input type="number" value="${en.h}" />
          <select>
            <option value="basic">basic</option>
            <option value="patrol">patrol</option>
            <option value="shooter">shooter</option>
            <option value="flyer">flyer</option>
          </select>
          <button data-idx="${idx}">Ã—</button>
        `;
        const inputs = row.querySelectorAll('input,select,button');
        const x = inputs[0];
        const y = inputs[1];
        const w = inputs[2];
        const h = inputs[3];
        const typeSel = inputs[4];
        const btn = inputs[5];
        x.oninput = () => { en.x = +x.value; draw(); };
        y.oninput = () => { en.y = +y.value; draw(); };
        w.oninput = () => { en.w = +w.value; draw(); };
        h.oninput = () => { en.h = +h.value; draw(); };
        typeSel.value = en.type || 'basic';
        typeSel.onchange = () => { en.type = typeSel.value; draw(); };
        btn.onclick = () => { lvl.enemies.splice(idx,1); renderForm(); draw(); };
        els.enemyList.appendChild(row);
      });
    }

    els.addPlatformBtn.onclick = () => {
      data.levels[current].platforms.push({ x: 100, y: 100, w: 100, h: 20 });
      renderForm();
      draw();
    };

    els.addEnemyBtn.onclick = () => {
      (data.levels[current].enemies || (data.levels[current].enemies = [])).push({ x: 200, y: 640, w: 28, h: 28, type: 'basic' });
      renderForm();
      draw();
    };

    els.addLevelBtn.onclick = () => {
      data.levels.push(structuredClone(DEFAULT_LEVEL));
      current = data.levels.length - 1;
      refreshLevelSelect();
      renderForm();
      draw();
    };

    els.deleteLevelBtn.onclick = () => {
      if (data.levels.length <= 1) return;
      data.levels.splice(current, 1);
      current = Math.max(0, current - 1);
      refreshLevelSelect();
      renderForm();
      draw();
    };

    els.levelSelect.onchange = () => {
      current = +els.levelSelect.value;
      renderForm();
      draw();
    };

    els.exportBtn.onclick = () => {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'levels.json';
      a.click();
      URL.revokeObjectURL(a.href);
    };

    els.importFile.onchange = async () => {
      const file = els.importFile.files?.[0];
      if (!file) return;
      const text = await file.text();
      try {
        const json = JSON.parse(text);
        if (!json.levels || !Array.isArray(json.levels)) throw new Error('levels[] manquant');
        data = json;
        current = 0;
        refreshLevelSelect();
        renderForm();
        draw();
      } catch (e) {
        alert('Fichier invalide: ' + e.message);
      } finally {
        els.importFile.value = '';
      }
    };

    // Canvas preview
    const ctx = els.view.getContext('2d');
    let zoom = 1;
    let scrollX = 0, scrollY = 0;
    let dragging = null; // { type: 'platform'|'goal'|'spawn'|'pan', idx?: number, dx, dy }

    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      els.view.width = Math.floor(els.view.clientWidth * dpr);
      els.view.height = Math.floor(els.view.clientHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      draw();
    }
    window.addEventListener('resize', resize);

    els.view.addEventListener('wheel', (e) => {
      if (e.ctrlKey) {
        e.preventDefault();
        const delta = Math.sign(e.deltaY);
        zoom = Math.min(3, Math.max(0.25, zoom * (delta > 0 ? 0.9 : 1.1)));
        draw();
      } else if (e.shiftKey) {
        e.preventDefault();
        scrollX += e.deltaY;
        draw();
      }
    }, { passive: false });

    function worldFromClient(e) {
      const rect = els.view.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (els.view.width / rect.width);
      const y = (e.clientY - rect.top) * (els.view.height / rect.height);
      const px = (x - scrollX) / zoom;
      const py = (y - scrollY) / zoom;
      return { px, py };
    }

    function doSnap(v) {
      const stepEl = document.getElementById('snapStep');
      const toggleEl = document.getElementById('snapToggle');
      const step = Math.max(1, +(stepEl?.value || 10));
      const use = !!(toggleEl?.checked);
      return use ? Math.round(v / step) * step : v;
    }

    function hitTest(lvl, x, y) {
      // Test plateformes en priorité (haut->bas)
      for (let i = lvl.platforms.length - 1; i >= 0; i--) {
        const p = lvl.platforms[i];
        if (x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h) {
          return { type: 'platform', idx: i };
        }
      }
      // Porte
      const g = lvl.goal;
      if (x >= g.x && x <= g.x + g.w && y >= g.y && y <= g.y + g.h) return { type: 'goal' };
      // Spawn (cercle rayon ~12)
      const dx = x - lvl.spawn.x, dy = y - lvl.spawn.y;
      if (dx*dx + dy*dy <= 12*12) return { type: 'spawn' };
      return null;
    }

    els.view.addEventListener('mousedown', (e) => {
      const btn = e.button; // 0: gauche, 1: milieu, 2: droit
      const lvl = data.levels[current];
      const { px, py } = worldFromClient(e);
      if (btn === 1) {
        dragging = { type: 'pan', dx: e.clientX, dy: e.clientY };
        return;
      }
      if (btn === 2) {
        // clic droit: delete plateforme sous la souris
        const hit = hitTest(lvl, px, py);
        if (hit?.type === 'platform') {
          lvl.platforms.splice(hit.idx, 1);
          renderForm();
          draw();
        }
        return;
      }
      // gauche: drag objet ou ajout si vide
      const hit = hitTest(lvl, px, py);
      if (hit) {
        if (hit.type === 'platform') {
          const p = lvl.platforms[hit.idx];
          dragging = { type: 'platform', idx: hit.idx, dx: px - p.x, dy: py - p.y };
        } else if (hit.type === 'goal') {
          dragging = { type: 'goal', dx: px - lvl.goal.x, dy: py - lvl.goal.y };
        } else if (hit.type === 'spawn') {
          dragging = { type: 'spawn', dx: px - lvl.spawn.x, dy: py - lvl.spawn.y };
        }
      } else {
        // ajout rapide si vide
        const nx = doSnap(Math.round(px));
        const ny = doSnap(Math.round(py));
        lvl.platforms.push({ x: nx, y: ny, w: 100, h: 20 });
        renderForm();
        draw();
      }
    });

    window.addEventListener('mouseup', () => { dragging = null; });

    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const lvl = data.levels[current];
      if (dragging.type === 'pan') {
        scrollX += (e.clientX - dragging.dx);
        scrollY += (e.clientY - dragging.dy);
        dragging.dx = e.clientX; dragging.dy = e.clientY;
        draw();
        return;
      }
      const { px, py } = worldFromClient(e);
      if (dragging.type === 'platform') {
        const p = lvl.platforms[dragging.idx];
        p.x = doSnap(px - dragging.dx);
        p.y = doSnap(py - dragging.dy);
      } else if (dragging.type === 'goal') {
        lvl.goal.x = doSnap(px - dragging.dx);
        lvl.goal.y = doSnap(py - dragging.dy);
      } else if (dragging.type === 'spawn') {
        lvl.spawn.x = doSnap(px - dragging.dx);
        lvl.spawn.y = doSnap(py - dragging.dy);
      }
      renderForm();
      draw();
    });

    function drawGrid() {
      const w = els.view.clientWidth, h = els.view.clientHeight;
      ctx.save();
      ctx.translate(scrollX, scrollY);
      ctx.scale(zoom, zoom);
      ctx.clearRect(-scrollX/zoom, -scrollY/zoom, w/zoom, h/zoom);
      const g = ctx.createLinearGradient(0, -scrollY/zoom, 0, h/zoom - scrollY/zoom);
      g.addColorStop(0, '#a9d3ff');
      g.addColorStop(1, '#e6f2ff');
      ctx.fillStyle = g;
      ctx.fillRect(-scrollX/zoom, -scrollY/zoom, w/zoom, h/zoom);
      const step = 50;
      // Lignes verticales (avec lignes majeures tous les 250px)
      for (let x = -scrollX/zoom % step; x < w/zoom; x += step) {
        const major = Math.round((x + scrollX/zoom)) % 250 === 0;
        ctx.strokeStyle = major ? '#b7d3ff' : '#d7eaff';
        ctx.lineWidth = major ? 1.2 : 1;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h/zoom);
        ctx.stroke();
      }
      // Lignes horizontales (avec lignes majeures tous les 250px)
      for (let y = -scrollY/zoom % step; y < h/zoom; y += step) {
        const major = Math.round((y + scrollY/zoom)) % 250 === 0;
        ctx.strokeStyle = major ? '#b7d3ff' : '#d7eaff';
        ctx.lineWidth = major ? 1.2 : 1;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w/zoom, y);
        ctx.stroke();
      }
      ctx.restore();
    }

    function draw() {
      const w = els.view.clientWidth, h = els.view.clientHeight;
      ctx.clearRect(0, 0, w, h);
      drawGrid();
      const lvl = data.levels[current];
      ctx.save();
      ctx.translate(scrollX, scrollY);
      ctx.scale(zoom, zoom);

      // Ground
      ctx.fillStyle = '#2e8b57';
      ctx.fillRect(lvl.ground.start_x, lvl.ground.y, lvl.ground.end_x - lvl.ground.start_x, 100);
      ctx.strokeStyle = '#1b5e3b';
      ctx.lineWidth = 2;
      ctx.strokeRect(lvl.ground.start_x, lvl.ground.y, Math.max(1, lvl.ground.end_x - lvl.ground.start_x), 100);

      // Platforms
      ctx.fillStyle = '#654321';
      ctx.strokeStyle = '#8b5a2b';
      lvl.platforms.forEach(p => {
        ctx.fillRect(p.x, p.y, p.w, p.h);
        ctx.strokeRect(p.x, p.y, p.w, p.h);
      });

      // Enemies
      if (lvl.enemies && lvl.enemies.length) {
        lvl.enemies.forEach(en => {
          const t = en.type || 'basic';
          const colors = {
            basic: ['#dc2626', '#7f1d1d'],
            patrol: ['#f97316', '#7c2d12'],
            shooter: ['#7c3aed', '#4c1d95'],
            flyer: ['#2563eb', '#1e3a8a']
          };
          const [fillC, strokeC] = colors[t] || colors.basic;
          ctx.fillStyle = fillC;
          ctx.strokeStyle = strokeC;
          ctx.lineWidth = 2;
          ctx.fillRect(en.x, en.y, en.w, en.h);
          ctx.strokeRect(en.x, en.y, en.w, en.h);
          // yeux
          ctx.fillStyle = '#fff';
          ctx.fillRect(en.x + 6, en.y + 8, 4, 6);
          ctx.fillRect(en.x + en.w - 10, en.y + 8, 4, 6);
          // label type
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.font = '12px ui-monospace, monospace';
          ctx.fillText(t, en.x, en.y - 6);
        });
      }

      // Goal
      ctx.fillStyle = '#b8860b';
      ctx.fillRect(lvl.goal.x, lvl.goal.y, lvl.goal.w, lvl.goal.h);
      ctx.strokeStyle = '#8b6508';
      ctx.lineWidth = 2;
      ctx.strokeRect(lvl.goal.x, lvl.goal.y, lvl.goal.w, lvl.goal.h);
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.font = '12px ui-monospace, monospace';
      ctx.fillText('Porte', lvl.goal.x, lvl.goal.y - 6);

      // Spawn
      ctx.fillStyle = '#1f6feb';
      ctx.beginPath();
      ctx.arc(lvl.spawn.x, lvl.spawn.y, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(31,110,235,0.6)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(lvl.spawn.x, lvl.spawn.y, 14, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.font = '12px ui-monospace, monospace';
      ctx.fillText('Spawn', lvl.spawn.x + 18, lvl.spawn.y + 4);

      ctx.restore();
    }

    // Init
    refreshLevelSelect();
    renderForm();
    resize();
    draw();
    // Mouse world coordinates display
    els.view.addEventListener('mousemove', (e) => {
      const rect = els.view.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (els.view.width / rect.width);
      const y = (e.clientY - rect.top) * (els.view.height / rect.height);
      let px = Math.round((x - scrollX) / zoom);
      let py = Math.round((y - scrollY) / zoom);
      px = doSnap(px); py = doSnap(py);
      const z = Math.round(zoom * 100) / 100;
      const el = document.getElementById('mouseInfo');
      if (el) el.textContent = `| Souris: ${px}, ${py} | Zoom: ${z}x`;
    });
  </script>
</body>
</html>
