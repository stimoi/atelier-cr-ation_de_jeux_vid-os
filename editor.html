<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>√âditeur de niveaux</title>
  <style>
    * { box-sizing: border-box; }
    body { 
      --sidebar-width: 380px;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; 
      margin: 0; 
      display: grid; 
      grid-template-columns: var(--sidebar-width) 8px 1fr; 
      height: 100vh; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      overflow: hidden;
      transition: grid-template-columns 0.2s ease;
    }
    .entity-editor {
      position: absolute;
      top: 24px;
      right: 24px;
      width: 280px;
      padding: 18px;
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.85);
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.45);
      backdrop-filter: blur(16px);
      border: 1px solid rgba(148, 163, 184, 0.25);
      color: #e2e8f0;
      display: none;
      flex-direction: column;
      gap: 14px;
      z-index: 50;
    }
    .entity-editor.visible {
      display: flex;
    }
    .entity-editor h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 700;
      color: #f8fafc;
    }
    .entity-editor__header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .entity-editor__header button {
      background: transparent;
      border: none;
      color: #94a3b8;
      cursor: pointer;
      font-size: 16px;
      padding: 4px;
    }
    .entity-editor__header button:hover {
      color: #e2e8f0;
    }
    .entity-editor label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 13px;
      color: #cbd5f5;
    }
    .entity-editor input,
    .entity-editor select {
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 10px;
      padding: 10px 12px;
      color: #f8fafc;
      font-size: 14px;
      transition: border-color 0.15s ease, box-shadow 0.15s ease;
    }
    .entity-editor input:focus,
    .entity-editor select:focus {
      outline: none;
      border-color: #38bdf8;
      box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.25);
    }
    .entity-editor__footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
    .entity-editor__footer button {
      border-radius: 999px;
      padding: 8px 16px;
      border: none;
      font-weight: 600;
      cursor: pointer;
    }
    .entity-editor__footer .btn-secondary {
      background: rgba(148, 163, 184, 0.15);
      color: #cbd5f5;
    }
    .entity-editor__footer .btn-secondary:hover {
      background: rgba(148, 163, 184, 0.25);
    }
    .entity-editor__footer .btn-primary {
      background: linear-gradient(135deg, #38bdf8, #0ea5e9);
      color: #0f172a;
    }
    .entity-editor__footer .btn-primary:hover {
      background: linear-gradient(135deg, #0ea5e9, #0284c7);
    }
    body.is-resizing {
      cursor: col-resize;
      user-select: none;
      transition: none;
    }
    header { 
      grid-column: 1 / -1; 
      padding: 16px 20px; 
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); 
      color: #fff; 
      display: flex; 
      align-items: center; 
      gap: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      border-bottom: 2px solid rgba(255,255,255,0.1);
    }
    header h1 { 
      font-size: 22px; 
      margin: 0; 
      font-weight: 600;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .sidebar { 
      overflow: auto; 
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(10px);
      border-right: 2px solid rgba(255,255,255,0.2); 
      padding: 20px; 
      display: flex; 
      flex-direction: column; 
      gap: 20px;
      box-shadow: 4px 0 20px rgba(0,0,0,0.1);
    }
    .sidebar::-webkit-scrollbar { width: 8px; }
    .sidebar::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); border-radius: 4px; }
    .sidebar::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 4px; }
    .sidebar::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.3); }
    .section { 
      border: 2px solid rgba(102, 126, 234, 0.2); 
      border-radius: 16px; 
      padding: 18px; 
      background: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
      box-shadow: 0 8px 25px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.8);
      transition: all 0.3s ease;
    }
    .section:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 35px rgba(0,0,0,0.12), inset 0 1px 0 rgba(255,255,255,0.9);
      border-color: rgba(102, 126, 234, 0.4);
    }
    .section h2 { 
      margin: 0 0 12px 0; 
      font-size: 18px; 
      font-weight: 600;
      color: #1e3a8a;
      text-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    label { 
      display: block; 
      font-size: 13px; 
      color: #374151; 
      margin-top: 10px; 
      font-weight: 500;
    }
    input[type="number"], input[type="text"], select { 
      width: 100%; 
      box-sizing: border-box; 
      padding: 10px 12px; 
      margin-top: 6px;
      border: 2px solid #e5e7eb;
      border-radius: 10px;
      font-size: 14px;
      transition: all 0.2s ease;
      background: #ffffff;
    }
    input[type="number"]:focus, input[type="text"]:focus, select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      transform: translateY(-1px);
    }
    button { 
      padding: 10px 16px; 
      border-radius: 10px; 
      border: 2px solid transparent; 
      background: linear-gradient(145deg, #f8fafc 0%, #e2e8f0 100%); 
      cursor: pointer;
      font-weight: 500;
      font-size: 14px;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }
    button.primary { 
      background: linear-gradient(145deg, #667eea 0%, #764ba2 100%); 
      color: white; 
      border-color: transparent;
    }
    button.primary:hover {
      background: linear-gradient(145deg, #5a67d8 0%, #6b46c1 100%);
    }
    button.danger { 
      background: linear-gradient(145deg, #f56565 0%, #e53e3e 100%); 
      color: white; 
      border-color: transparent;
    }
    button.danger:hover {
      background: linear-gradient(145deg, #e53e3e 0%, #c53030 100%);
    }
    .row { display: flex; gap: 10px; align-items: center; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .platforms { 
      display: flex; 
      flex-direction: column; 
      gap: 10px; 
      max-height: 280px; 
      overflow: auto;
      padding: 8px;
      background: rgba(0,0,0,0.02);
      border-radius: 8px;
    }
    .platforms::-webkit-scrollbar { width: 6px; }
    .platforms::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); border-radius: 3px; }
    .platforms::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 3px; }
    .platform { 
      display: grid; 
      grid-template-columns: repeat(4, 1fr) 40px; 
      gap: 8px; 
      padding: 8px;
      background: rgba(255,255,255,0.8);
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,0.1);
    }
    .canvas-wrap { 
      position: relative; 
      height: calc(100vh - 80px); 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      overflow: hidden;
    }
    .sidebar-resizer {
      position: relative;
      cursor: col-resize;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255,255,255,0.2);
      transition: background 0.2s ease;
    }
    .sidebar-resizer::before {
      content: '';
      width: 3px;
      height: 40px;
      border-radius: 999px;
      background: rgba(255,255,255,0.7);
      box-shadow: 0 0 8px rgba(0,0,0,0.15);
    }
    .sidebar-resizer:hover {
      background: rgba(255,255,255,0.35);
    }
    canvas { 
      width: 100%; 
      height: 100%; 
      display: block; 
      background: linear-gradient(180deg, #87ceeb 0%, #e0f6ff 50%, #98fb98 100%);
      cursor: crosshair;
    }
    .toolbar { 
      position: absolute; 
      top: 16px; 
      left: 16px; 
      display: flex; 
      gap: 12px; 
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(10px);
      padding: 12px 16px; 
      border-radius: 16px; 
      box-shadow: 0 8px 25px rgba(0,0,0,0.15);
      border: 2px solid rgba(255,255,255,0.3);
    }
    .navigation-help {
      position: absolute;
      bottom: 16px;
      left: 16px;
      background: rgba(30, 60, 114, 0.9);
      color: white;
      padding: 12px 16px;
      border-radius: 12px;
      font-size: 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      transition: opacity 0.6s ease, transform 0.6s ease;
      opacity: 1;
    }
    .navigation-help.is-hidden {
      opacity: 0;
      transform: translateY(16px);
      pointer-events: none;
    }
    .context-menu {
      position: absolute;
      min-width: 200px;
      background: rgba(30, 58, 138, 0.95);
      color: #fff;
      border-radius: 12px;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.35);
      border: 1px solid rgba(148, 163, 184, 0.4);
      backdrop-filter: blur(12px);
      padding: 8px 0;
      display: none;
      z-index: 20;
      overflow: hidden;
      animation: fadeIn 0.18s ease;
    }
    .context-menu.visible {
      display: block;
    }
    .context-menu button {
      width: 100%;
      background: transparent;
      border: none;
      color: inherit;
      padding: 10px 18px;
      text-align: left;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: background 0.15s ease;
    }
    .context-menu button:hover {
      background: rgba(255, 255, 255, 0.12);
    }
    .context-menu button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      background: transparent;
    }
    .context-menu button.context-danger {
      color: #fecaca;
    }
    .context-submenu {
      margin-top: 6px;
      padding-left: 14px;
      border-left: 1px solid rgba(255,255,255,0.08);
      display: none;
      flex-direction: column;
      gap: 4px;
    }
    .context-submenu.visible {
      display: flex;
    }
    .context-submenu button {
      font-size: 13px;
    }
    .context-section {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin: 8px 0;
    }
    .context-section__title {
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: rgba(226, 232, 240, 0.6);
      padding-left: 4px;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }
    small.mono { 
      font-family: 'SF Mono', ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; 
      color: #64748b; 
      font-size: 12px;
    }
    .tag { 
      padding: 4px 8px; 
      border-radius: 20px; 
      font-size: 11px; 
      font-weight: 600;
      border: 1px solid transparent;
    }
    .tag.enemy { 
      background: linear-gradient(145deg, #fee2e2 0%, #fecaca 100%); 
      color: #991b1b; 
      border-color: #fca5a5;
    }
    .list-headers { 
      display: grid; 
      gap: 8px; 
      font-size: 12px; 
      color: #6b7280; 
      padding: 0 4px;
      font-weight: 600;
    }
    .list-headers.platform { grid-template-columns: repeat(4, 1fr) 40px; }
    .list-headers.enemy { grid-template-columns: repeat(4, 1fr) 1fr 40px; }
    .list-headers span { font-weight: 700; }
    .enemy-type { 
      display: inline-block; 
      width: 70px; 
      text-align: center;
      padding: 2px 6px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 600;
    }
    .enemy-type.basic { background: linear-gradient(145deg, #fee2e2 0%, #fecaca 100%); color: #991b1b; }
    .enemy-type.patrol { background: linear-gradient(145deg, #fed7aa 0%, #fdba74 100%); color: #9a3412; }
    .enemy-type.shooter { background: linear-gradient(145deg, #dcfce7 0%, #bbf7d0 100%); color: #166534; }
    .enemy-type.flyer { background: linear-gradient(145deg, #e0e7ff 0%, #c7d2fe 100%); color: #3730a3; }
  </style>
</head>
<body>
  <header>
    <h1>√âditeur de niveaux</h1>
    <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
      <input type="file" id="importFile" accept="application/json" />
      <button class="primary" id="exportBtn">Exporter levels.json</button>
    </div>
  </header>

  <div class="sidebar">
    <div class="section">
      <h2>Niveaux</h2>
      <div class="row">
        <select id="levelSelect" style="flex:1"></select>
        <button id="addLevelBtn">Ajouter</button>
        <button class="danger" id="deleteLevelBtn">Supprimer</button>
      </div>
      <label>Nom</label>
      <input type="text" id="levelName" placeholder="Nom du niveau" />
    </div>

    <div class="section">
      <h2>Sol</h2>
      <div class="grid-2">
        <div>
          <label>Y</label>
          <input type="number" id="groundY" />
        </div>
        <div>
          <label>D√©but X</label>
          <input type="number" id="groundStart" />
        </div>
        <div>
          <label>Fin X</label>
          <input type="number" id="groundEnd" />
        </div>
      </div>
    </div>

    <div class="section">
      <h2>Spawn</h2>
      <div class="grid-2">
        <div>
          <label>X</label>
          <input type="number" id="spawnX" />
        </div>
        <div>
          <label>Y</label>
          <input type="number" id="spawnY" />
        </div>
      </div>
      <label>Position de d√©part</label>
    </div>

    <div class="section">
      <h2>But (porte)</h2>
      <div class="grid-2">
        <div>
          <label>X</label>
          <input type="number" id="goalX" />
        </div>
        <div>
          <label>Y</label>
          <input type="number" id="goalY" />
        </div>
        <div>
          <label>Largeur</label>
          <input type="number" id="goalW" />
        </div>
        <div>
          <label>Hauteur</label>
          <input type="number" id="goalH" />
        </div>
      </div>
      <label>Position de la porte</label>
    </div>

    <div class="section">
      <h2>Plateformes</h2>
      <div class="list-headers platform">
        <span>X</span>
        <span>Y</span>
        <span>Largeur</span>
        <span>Hauteur</span>
        <span></span>
      </div>
      <div class="platforms" id="platformList"></div>
      <button id="addPlatformBtn">+ Ajouter une plateforme</button>
      <small class="mono">Astuce: cliquez dans la pr√©visualisation pour ajouter rapidement (100x20).</small>
    </div>

    <div class="section">
      <h2>Ennemis <span class="tag enemy">danger</span></h2>
      <div class="list-headers enemy">
        <span>X</span>
        <span>Y</span>
        <span>Largeur</span>
        <span>Hauteur</span>
        <span>Type</span>
        <span></span>
      </div>
      <div class="platforms" id="enemyList"></div>
      <button id="addEnemyBtn">+ Ajouter un ennemi</button>
      <small class="mono">Conseil: placez-les au-dessus du sol et des plateformes.</small>
    </div>
  </div>

  <div class="sidebar-resizer" id="sidebarResizer" title="Redimensionner"></div>

  <div class="canvas-wrap">
    <div class="toolbar">
      <small class="mono">üéÆ Navigation: Fl√®ches ou WASD</small>
      <small class="mono">üîç Zoom: Ctrl + molette</small>
      <small class="mono" id="mouseInfo"></small>
      <label class="mono" style="display:flex;align-items:center;gap:6px;margin-left:8px;">
        <input type="checkbox" id="snapToggle" checked>
        Snap
      </label>
      <label class="mono" style="display:flex;align-items:center;gap:6px;">
        Pas
        <input type="number" id="snapStep" value="10" min="1" style="width:64px;">
      </label>
    </div>
    <div class="navigation-help">
      <div><strong>üöÄ Navigation Infinie</strong></div>
      <div>‚Ä¢ Fl√®ches / WASD: D√©placer la vue</div>
      <div>‚Ä¢ Molette: Zoom</div>
      <div>‚Ä¢ Clic milieu + glisser: Panoramique</div>
      <div>‚Ä¢ Clic gauche: Ajouter/d√©placer</div>
      <div>‚Ä¢ Clic droit: Menu contextuel</div>
    </div>
    <canvas id="view"></canvas>
    <div class="context-menu" id="canvasContextMenu">
      <button type="button" data-action="modify-menu">‚úèÔ∏è Modifier‚Ä¶</button>
      <div class="context-submenu" id="contextModifyMenu">
        <button type="button" data-action="modify-enemy">üëæ Modifier le monstre</button>
        <button type="button" data-action="modify-platform">‚¨õ Modifier la plateforme</button>
      </div>
      <hr />
      <div class="context-section">
        <div class="context-section__title">Ajouter / Retirer</div>
        <button type="button" data-action="add-enemy">üëæ Ajouter un ennemi</button>
        <button type="button" data-action="delete-enemy" class="context-danger">üóëÔ∏è Supprimer l'ennemi</button>
        <button type="button" data-action="delete-platform" class="context-danger">‚úñÔ∏è Supprimer la plateforme</button>
      </div>
      <hr />
      <button type="button" data-action="set-spawn">üéØ Placer le spawn ici</button>
      <button type="button" data-action="set-goal">üö™ D√©placer la porte ici</button>
    </div>
    <div class="entity-editor" id="entityEditor">
      <div class="entity-editor__header">
        <h3 id="entityEditorTitle">Modifier</h3>
        <button type="button" id="entityEditorClose" aria-label="Fermer">‚úï</button>
      </div>
      <div class="entity-editor__body">
        <label>
          Position X
          <input type="number" id="entityEditorX" />
        </label>
        <label>
          Position Y
          <input type="number" id="entityEditorY" />
        </label>
        <label>
          Largeur
          <input type="number" id="entityEditorWidth" min="1" />
        </label>
        <label>
          Hauteur
          <input type="number" id="entityEditorHeight" min="1" />
        </label>
        <label id="entityEditorTypeWrap">
          Type d'ennemi
          <select id="entityEditorType">
            <option value="basic">basic</option>
            <option value="patrol">patrol</option>
            <option value="shooter">shooter</option>
            <option value="flyer">flyer</option>
          </select>
        </label>
      </div>
      <div class="entity-editor__footer">
        <button type="button" class="btn-secondary" id="entityEditorCancel">Annuler</button>
        <button type="button" class="btn-primary" id="entityEditorSave">Sauvegarder</button>
      </div>
    </div>
  </div>

  <script>
    const DEFAULT_LEVEL = {
      name: 'Niveau vide',
      ground: { y: 0, start_x: 0, end_x: 10000 },
      spawn: { x: 40, y: -40 },
      goal: { x: 1000, y: -110, w: 70, h: 110 },
      platforms: [],
      enemies: []
    };

    let data = { levels: [ structuredClone(DEFAULT_LEVEL) ] };
    let current = 0;

    const els = {
      levelSelect: document.getElementById('levelSelect'),
      levelName: document.getElementById('levelName'),
      groundY: document.getElementById('groundY'),
      groundStart: document.getElementById('groundStart'),
      groundEnd: document.getElementById('groundEnd'),
      spawnX: document.getElementById('spawnX'),
      spawnY: document.getElementById('spawnY'),
      goalX: document.getElementById('goalX'),
      goalY: document.getElementById('goalY'),
      goalW: document.getElementById('goalW'),
      goalH: document.getElementById('goalH'),
      platformList: document.getElementById('platformList'),
      enemyList: document.getElementById('enemyList'),
      addPlatformBtn: document.getElementById('addPlatformBtn'),
      addEnemyBtn: document.getElementById('addEnemyBtn'),
      addLevelBtn: document.getElementById('addLevelBtn'),
      deleteLevelBtn: document.getElementById('deleteLevelBtn'),
      exportBtn: document.getElementById('exportBtn'),
      importFile: document.getElementById('importFile'),
      view: document.getElementById('view'),
      contextMenu: document.getElementById('canvasContextMenu'),
      sidebar: document.querySelector('.sidebar'),
      resizer: document.getElementById('sidebarResizer')
    };

    const navigationHelp = document.querySelector('.navigation-help');
    if (navigationHelp) {
      setTimeout(() => navigationHelp.classList.add('is-hidden'), 10000);
    }

    const SIDEBAR_MIN_WIDTH = 260;
    const SIDEBAR_MAX_WIDTH = 600;
    let isResizingSidebar = false;

    function clampSidebarWidth(width) {
      return Math.min(SIDEBAR_MAX_WIDTH, Math.max(SIDEBAR_MIN_WIDTH, width));
    }

    function applySidebarWidth(width) {
      document.body.style.setProperty('--sidebar-width', `${Math.round(width)}px`);
      resize();
    }

    els.resizer?.addEventListener('mousedown', (e) => {
      e.preventDefault();
      hideContextMenu();
      isResizingSidebar = true;
      document.body.classList.add('is-resizing');
    });

    window.addEventListener('mousemove', (e) => {
      if (!isResizingSidebar) return;
      const newWidth = clampSidebarWidth(e.clientX);
      applySidebarWidth(newWidth);
    });

    window.addEventListener('mouseup', () => {
      if (!isResizingSidebar) return;
      isResizingSidebar = false;
      document.body.classList.remove('is-resizing');
    });

    const contextMenuState = {
      visible: false,
      clientX: 0,
      clientY: 0,
      worldX: 0,
      worldY: 0,
      hit: null
    };

    function hideContextMenu() {
      if (!contextMenuState.visible) return;
      contextMenuState.visible = false;
      contextMenuState.hit = null;
      els.contextMenu?.classList.remove('visible');
      const submenu = els.contextMenu?.querySelector('.context-submenu');
      if (submenu) submenu.classList.remove('visible');
    }

    function showContextMenu(e, hitInfo) {
      hideContextMenu();
      if (!els.contextMenu) return;
      const menu = els.contextMenu;
      contextMenuState.visible = true;
      const { px, py } = worldFromClient(e);
      contextMenuState.clientX = e.clientX;
      contextMenuState.clientY = e.clientY;
      contextMenuState.worldX = px;
      contextMenuState.worldY = py;
      contextMenuState.hit = hitInfo;

      const deletePlatformBtn = menu.querySelector('[data-action="delete-platform"]');
      if (deletePlatformBtn) {
        deletePlatformBtn.disabled = !(hitInfo && hitInfo.type === 'platform');
      }
      const modifyBtn = menu.querySelector('[data-action="modify-menu"]');
      if (modifyBtn) {
        modifyBtn.disabled = !(hitInfo && (hitInfo.type === 'enemy' || hitInfo.type === 'platform'));
      }
      const submenu = menu.querySelector('.context-submenu');
      if (submenu) {
        submenu.classList.remove('visible');
      }
      const modifyEnemyBtn = menu.querySelector('[data-action="modify-enemy"]');
      if (modifyEnemyBtn) {
        modifyEnemyBtn.disabled = !(hitInfo && hitInfo.type === 'enemy');
      }
      const deleteEnemyBtn = menu.querySelector('[data-action="delete-enemy"]');
      if (deleteEnemyBtn) {
        deleteEnemyBtn.disabled = !(hitInfo && hitInfo.type === 'enemy');
      }
      const modifyPlatformBtn = menu.querySelector('[data-action="modify-platform"]');
      if (modifyPlatformBtn) {
        modifyPlatformBtn.disabled = !(hitInfo && hitInfo.type === 'platform');
      }

      menu.classList.add('visible');
      menu.style.left = '0px';
      menu.style.top = '0px';
      const bounds = menu.getBoundingClientRect();
      const containerRect = els.view.getBoundingClientRect();
      const padding = 8;
      const offsetX = e.clientX - containerRect.left;
      const offsetY = e.clientY - containerRect.top;
      const containerWidth = containerRect.width;
      const containerHeight = containerRect.height;

      let x = offsetX + 12;
      let y = offsetY - bounds.height - 12;

      const maxX = containerWidth - bounds.width - padding;
      if (x > maxX) x = Math.max(padding, maxX);
      if (x < padding) x = padding;

      if (y < padding) {
        const belowY = offsetY + 12;
        if (belowY + bounds.height <= containerHeight - padding) {
          y = belowY;
        } else {
          y = Math.max(padding, containerHeight - bounds.height - padding);
        }
      }

      menu.style.left = `${x}px`;
      menu.style.top = `${y}px`;
    }

    function refreshLevelSelect() {
      els.levelSelect.innerHTML = '';
      data.levels.forEach((lvl, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = `${i+1}. ${lvl.name || 'Sans nom'}`;
        els.levelSelect.appendChild(opt);
      });
      els.levelSelect.value = String(current);
    }

    function bindValue(input, getter, setter) {
      input.value = getter();
      input.oninput = () => { setter(Number.isFinite(+input.value) ? +input.value : input.value); draw(); };
    }

    function renderForm() {
      const lvl = data.levels[current];
      els.levelName.value = lvl.name || '';
      bindValue(els.groundY, () => lvl.ground.y, v => lvl.ground.y = v);
      bindValue(els.groundStart, () => lvl.ground.start_x, v => lvl.ground.start_x = v);
      bindValue(els.groundEnd, () => lvl.ground.end_x, v => lvl.ground.end_x = v);
      bindValue(els.spawnX, () => lvl.spawn.x, v => lvl.spawn.x = v);
      bindValue(els.spawnY, () => lvl.spawn.y, v => lvl.spawn.y = v);
      bindValue(els.goalX, () => lvl.goal.x, v => lvl.goal.x = v);
      bindValue(els.goalY, () => lvl.goal.y, v => lvl.goal.y = v);
      bindValue(els.goalW, () => lvl.goal.w, v => lvl.goal.w = v);
      bindValue(els.goalH, () => lvl.goal.h, v => lvl.goal.h = v);

      els.levelName.oninput = () => { lvl.name = els.levelName.value; refreshLevelSelect(); };

      els.platformList.innerHTML = '';
      lvl.platforms.forEach((p, idx) => {
        const row = document.createElement('div');
        row.className = 'platform';
        row.innerHTML = `
          <input type="number" value="${p.x}" />
          <input type="number" value="${p.y}" />
          <input type="number" value="${p.w}" />
          <input type="number" value="${p.h}" />
          <button data-idx="${idx}">√É‚Äî</button>
        `;
        const [x,y,w,h,btn] = row.querySelectorAll('input,button');
        x.oninput = () => { p.x = +x.value; draw(); };
        y.oninput = () => { p.y = +y.value; draw(); };
        w.oninput = () => { p.w = +w.value; draw(); };
        h.oninput = () => { p.h = +h.value; draw(); };
        btn.onclick = () => { lvl.platforms.splice(idx,1); renderForm(); draw(); };
        els.platformList.appendChild(row);
      });

      els.enemyList.innerHTML = '';
      (lvl.enemies || (lvl.enemies = [])).forEach((en, idx) => {
        const row = document.createElement('div');
        row.className = 'platform';
        row.style.gridTemplateColumns = 'repeat(4, 1fr) 1fr 32px';
        row.innerHTML = `
          <input type="number" value="${en.x}" />
          <input type="number" value="${en.y}" />
          <input type="number" value="${en.w}" />
          <input type="number" value="${en.h}" />
          <select>
            <option value="basic">basic</option>
            <option value="patrol">patrol</option>
            <option value="shooter">shooter</option>
            <option value="flyer">flyer</option>
          </select>
          <button data-idx="${idx}">√É‚Äî</button>
        `;
        const inputs = row.querySelectorAll('input,select,button');
        const x = inputs[0];
        const y = inputs[1];
        const w = inputs[2];
        const h = inputs[3];
        const typeSel = inputs[4];
        const btn = inputs[5];
        x.oninput = () => { en.x = +x.value; draw(); };
        y.oninput = () => { en.y = +y.value; draw(); };
        w.oninput = () => { en.w = +w.value; draw(); };
        h.oninput = () => { en.h = +h.value; draw(); };
        typeSel.value = en.type || 'basic';
        typeSel.onchange = () => { en.type = typeSel.value; draw(); };
        btn.onclick = () => { lvl.enemies.splice(idx,1); renderForm(); draw(); };
        els.enemyList.appendChild(row);
      });
    }

    els.addPlatformBtn.onclick = () => {
      data.levels[current].platforms.push({ x: 100, y: 100, w: 100, h: 20 });
      renderForm();
      draw();
    };

    els.addEnemyBtn.onclick = () => {
      (data.levels[current].enemies || (data.levels[current].enemies = [])).push({ x: 200, y: 640, w: 28, h: 28, type: 'basic' });
      renderForm();
      draw();
    };

    els.addLevelBtn.onclick = () => {
      data.levels.push(structuredClone(DEFAULT_LEVEL));
      current = data.levels.length - 1;
      refreshLevelSelect();
      renderForm();
      draw();
    };

    els.deleteLevelBtn.onclick = () => {
      if (data.levels.length <= 1) return;
      data.levels.splice(current, 1);
      current = Math.max(0, current - 1);
      refreshLevelSelect();
      renderForm();
      draw();
    };

    els.levelSelect.onchange = () => {
      current = +els.levelSelect.value;
      renderForm();
      draw();
    };

    els.exportBtn.onclick = () => {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'levels.json';
      a.click();
      URL.revokeObjectURL(a.href);
    };

    els.importFile.onchange = async () => {
      const file = els.importFile.files?.[0];
      if (!file) return;
      const text = await file.text();
      try {
        const json = JSON.parse(text);
        if (!json.levels || !Array.isArray(json.levels)) throw new Error('levels[] manquant');
        data = json;
        current = 0;
        refreshLevelSelect();
        renderForm();
        draw();
      } catch (e) {
        alert('Fichier invalide: ' + e.message);
      } finally {
        els.importFile.value = '';
      }
    };

    // Canvas preview
    const ctx = els.view.getContext('2d');
    let zoom = 1;
    let scrollX = 0, scrollY = 0;
    let dragging = null; // { type: 'platform'|'goal'|'spawn'|'pan', idx?: number, dx, dy }

    // Navigation infinie avec le clavier
    const keys = {};
    const MOVE_SPEED = 600; // pixels par seconde
    let lastTime = 0;

    // Gestion des touches
    window.addEventListener('keydown', (e) => {
      // Emp√™cher le d√©filement de la page
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyZ', 'KeyQ'].includes(e.code)) {
        e.preventDefault();
      }
      keys[e.code] = true;
    });

    window.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });

    // Boucle d'animation pour la navigation fluide
    function updateNavigation(currentTime) {
      if (lastTime === 0) lastTime = currentTime;
      const deltaTime = (currentTime - lastTime) / 1000; // en secondes
      lastTime = currentTime;

      let moved = false;
      const moveDistance = MOVE_SPEED * deltaTime;

      // Navigation avec les fl√®ches ou WASD
      if (keys['ArrowLeft'] || keys['KeyA'] || keys['KeyQ']) {
        scrollX += moveDistance;
        moved = true;
      }
      if (keys['ArrowRight'] || keys['KeyD']) {
        scrollX -= moveDistance;
        moved = true;
      }
      if (keys['ArrowUp'] || keys['KeyW'] || keys['KeyZ']) {
        scrollY += moveDistance;
        moved = true;
      }
      if (keys['ArrowDown'] || keys['KeyS']) {
        scrollY -= moveDistance;
        moved = true;
      }

      if (moved) {
        draw();
      }

      requestAnimationFrame(updateNavigation);
    }

    // D√©marrer la boucle d'animation
    requestAnimationFrame(updateNavigation);

    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      els.view.width = Math.floor(els.view.clientWidth * dpr);
      els.view.height = Math.floor(els.view.clientHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      draw();
    }
    window.addEventListener('resize', resize);

    els.view.addEventListener('wheel', (e) => {
      hideContextMenu();
      if (e.ctrlKey) {
        // Zoom avec Ctrl + molette
        e.preventDefault();
        const delta = Math.sign(e.deltaY);
        const rect = els.view.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Zoom centr√© sur la souris
        const worldX = (mouseX - scrollX) / zoom;
        const worldY = (mouseY - scrollY) / zoom;

        const newZoom = Math.min(5, Math.max(0.1, zoom * (delta > 0 ? 0.9 : 1.1)));

        scrollX = mouseX - worldX * newZoom;
        scrollY = mouseY - worldY * newZoom;
        zoom = newZoom;

        draw();
      } else {
        // D√©placement vertical avec la molette normale (sens naturel)
        e.preventDefault();
        scrollY -= e.deltaY * 0.5;
        draw();
      }
    }, { passive: false });

    function worldFromClient(e) {
      const rect = els.view.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (els.view.width / rect.width);
      const y = (e.clientY - rect.top) * (els.view.height / rect.height);
      const px = (x - scrollX) / zoom;
      const py = (y - scrollY) / zoom;
      return { px, py };
    }

    function doSnap(v) {
      const stepEl = document.getElementById('snapStep');
      const toggleEl = document.getElementById('snapToggle');
      const step = Math.max(1, +(stepEl?.value || 10));
      const use = !!(toggleEl?.checked);
      return use ? Math.round(v / step) * step : v;
    }

    function hitTest(lvl, x, y) {
      // Test plateformes en priorit√© (haut->bas)
      for (let i = lvl.platforms.length - 1; i >= 0; i--) {
        const p = lvl.platforms[i];
        if (x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h) {
          return { type: 'platform', idx: i };
        }
      }
      // Ennemis
      if (Array.isArray(lvl.enemies)) {
        for (let i = lvl.enemies.length - 1; i >= 0; i--) {
          const en = lvl.enemies[i];
          if (x >= en.x && x <= en.x + (en.w || 0) && y >= en.y && y <= en.y + (en.h || 0)) {
            return { type: 'enemy', idx: i };
          }
        }
      }
      // Porte
      const g = lvl.goal;
      if (x >= g.x && x <= g.x + g.w && y >= g.y && y <= g.y + g.h) return { type: 'goal' };
      // Spawn (cercle rayon ~12)
      const dx = x - lvl.spawn.x, dy = y - lvl.spawn.y;
      if (dx*dx + dy*dy <= 12*12) return { type: 'spawn' };
      return null;
    }

    const entityEditorEls = {
      container: document.getElementById('entityEditor'),
      title: document.getElementById('entityEditorTitle'),
      x: document.getElementById('entityEditorX'),
      y: document.getElementById('entityEditorY'),
      w: document.getElementById('entityEditorWidth'),
      h: document.getElementById('entityEditorHeight'),
      typeWrap: document.getElementById('entityEditorTypeWrap'),
      type: document.getElementById('entityEditorType'),
      save: document.getElementById('entityEditorSave'),
      cancel: document.getElementById('entityEditorCancel'),
      close: document.getElementById('entityEditorClose'),
    };

    let editingEntity = null;

    function openEntityEditor(type, index) {
      const lvl = data.levels[current];
      if (!lvl) return;
      let entity = null;
      if (type === 'enemy') {
        if (!Array.isArray(lvl.enemies) || !lvl.enemies[index]) return;
        entity = lvl.enemies[index];
      } else if (type === 'platform') {
        if (!lvl.platforms[index]) return;
        entity = lvl.platforms[index];
      }
      if (!entity) return;

      editingEntity = { type, index };
      entityEditorEls.title.textContent = type === 'enemy' ? 'Modifier un ennemi' : 'Modifier une plateforme';
      entityEditorEls.typeWrap.style.display = type === 'enemy' ? 'flex' : 'none';

      entityEditorEls.x.value = Number.isFinite(entity.x) ? entity.x : 0;
      entityEditorEls.y.value = Number.isFinite(entity.y) ? entity.y : 0;
      entityEditorEls.w.value = Number.isFinite(entity.w) ? entity.w : (entity.radius ? entity.radius * 2 : 0);
      entityEditorEls.h.value = Number.isFinite(entity.h) ? entity.h : (entity.radius ? entity.radius * 2 : 0);
      if (type === 'enemy') {
        entityEditorEls.type.value = entity.type || 'basic';
      }

      entityEditorEls.container.classList.add('visible');
    }

    function closeEntityEditor() {
      editingEntity = null;
      entityEditorEls.container.classList.remove('visible');
    }

    function saveEntityEditor() {
      if (!editingEntity) return;
      const lvl = data.levels[current];
      if (!lvl) return;
      const xVal = parseFloat(entityEditorEls.x.value);
      const yVal = parseFloat(entityEditorEls.y.value);
      const wVal = parseFloat(entityEditorEls.w.value);
      const hVal = parseFloat(entityEditorEls.h.value);
      if (!Number.isFinite(xVal) || !Number.isFinite(yVal) || !Number.isFinite(wVal) || !Number.isFinite(hVal) || wVal <= 0 || hVal <= 0) {
        alert('Veuillez saisir des valeurs valides.');
        return;
      }

      if (editingEntity.type === 'enemy') {
        const enemy = lvl.enemies[editingEntity.index];
        if (!enemy) return;
        enemy.x = doSnap(xVal);
        enemy.y = doSnap(yVal);
        enemy.w = doSnap(wVal);
        enemy.h = doSnap(hVal);
        enemy.type = entityEditorEls.type.value || enemy.type || 'basic';
      } else if (editingEntity.type === 'platform') {
        const platform = lvl.platforms[editingEntity.index];
        if (!platform) return;
        platform.x = doSnap(xVal);
        platform.y = doSnap(yVal);
        platform.w = doSnap(wVal);
        platform.h = doSnap(hVal);
      }

      renderForm();
      draw();
      closeEntityEditor();
    }

    entityEditorEls.save?.addEventListener('click', saveEntityEditor);
    entityEditorEls.cancel?.addEventListener('click', closeEntityEditor);
    entityEditorEls.close?.addEventListener('click', closeEntityEditor);

    els.view.addEventListener('mousedown', (e) => {
      hideContextMenu();
      const btn = e.button; // 0: gauche, 1: milieu, 2: droit
      const lvl = data.levels[current];
      const { px, py } = worldFromClient(e);
      if (btn === 1) {
        dragging = { type: 'pan', dx: e.clientX, dy: e.clientY, moved: false };
        return;
      }
      if (btn === 2) {
        return;
      }
      // gauche: drag objet ou ajout si vide
      const hit = hitTest(lvl, px, py);
      if (hit) {
        if (hit.type === 'platform') {
          const p = lvl.platforms[hit.idx];
          dragging = { type: 'platform', idx: hit.idx, dx: px - p.x, dy: py - p.y, moved: false };
        } else if (hit.type === 'goal') {
          dragging = { type: 'goal', dx: px - lvl.goal.x, dy: py - lvl.goal.y, moved: false };
        } else if (hit.type === 'spawn') {
          dragging = { type: 'spawn', dx: px - lvl.spawn.x, dy: py - lvl.spawn.y, moved: false };
        } else if (hit.type === 'enemy') {
          openEntityEditor('enemy', hit.idx);
        }
      } else {
        // ajout rapide si vide
        const nx = doSnap(Math.round(px));
        const ny = doSnap(Math.round(py));
        lvl.platforms.push({ x: nx, y: ny, w: 100, h: 20 });
        renderForm();
        draw();
      }
    });

    els.view.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const lvl = data.levels[current];
      const { px, py } = worldFromClient(e);
      const hit = hitTest(lvl, px, py);
      showContextMenu(e, hit);
    });

    window.addEventListener('mouseup', () => {
      if (!dragging) return;
      dragging = null;
    });

    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const lvl = data.levels[current];
      if (dragging.type === 'pan') {
        scrollX += (e.clientX - dragging.dx);
        scrollY += (e.clientY - dragging.dy);
        dragging.dx = e.clientX; dragging.dy = e.clientY;
        dragging.moved = true;
        draw();
        return;
      }
      const { px, py } = worldFromClient(e);
      if (dragging.type === 'platform') {
        const p = lvl.platforms[dragging.idx];
        const prevX = p.x;
        const prevY = p.y;
        p.x = doSnap(px - dragging.dx);
        p.y = doSnap(py - dragging.dy);
        if (p.x !== prevX || p.y !== prevY) {
          dragging.moved = true;
        }
      } else if (dragging.type === 'goal') {
        lvl.goal.x = doSnap(px - dragging.dx);
        lvl.goal.y = doSnap(py - dragging.dy);
        dragging.moved = true;
      } else if (dragging.type === 'spawn') {
        lvl.spawn.x = doSnap(px - dragging.dx);
        lvl.spawn.y = doSnap(py - dragging.dy);
        dragging.moved = true;
      }
      renderForm();
      draw();
    });

    if (els.contextMenu) {
      els.contextMenu.addEventListener('mousedown', (e) => e.stopPropagation());
      els.contextMenu.addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (!btn || btn.disabled) return;
        const action = btn.dataset.action;
        const lvl = data.levels[current];
        const wx = doSnap(contextMenuState.worldX);
        const wy = doSnap(contextMenuState.worldY);
        switch (action) {
          case 'add-enemy': {
            const enemies = lvl.enemies || (lvl.enemies = []);
            enemies.push({ x: wx, y: wy, w: 28, h: 28, type: 'basic' });
            break;
          }
          case 'set-spawn': {
            lvl.spawn.x = wx;
            lvl.spawn.y = wy;
            break;
          }
          case 'set-goal': {
            lvl.goal.x = wx;
            lvl.goal.y = wy;
            break;
          }
          case 'modify-menu': {
            const submenu = els.contextMenu?.querySelector('.context-submenu');
            if (!btn.disabled && submenu) {
              submenu.classList.toggle('visible');
            }
            // Ne pas fermer le menu imm√©diatement
            return;
          }
          case 'modify-enemy': {
            if (contextMenuState.hit && contextMenuState.hit.type === 'enemy') {
              openEntityEditor('enemy', contextMenuState.hit.idx);
            }
            break;
          }
          case 'modify-platform': {
            if (contextMenuState.hit && contextMenuState.hit.type === 'platform') {
              openEntityEditor('platform', contextMenuState.hit.idx);
            }
            break;
          }
          case 'delete-platform': {
            if (contextMenuState.hit && contextMenuState.hit.type === 'platform') {
              lvl.platforms.splice(contextMenuState.hit.idx, 1);
            }
            break;
          }
          case 'delete-enemy': {
            if (contextMenuState.hit && contextMenuState.hit.type === 'enemy') {
              lvl.enemies.splice(contextMenuState.hit.idx, 1);
            }
            break;
          }
          default:
            break;
        }
        renderForm();
        draw();
        hideContextMenu();
        // Ouvrir le sous-menu ne doit pas fermer le menu
        if (action === 'modify-menu') {
          return;
        }
      });
    }

    document.addEventListener('mousedown', (e) => {
      if (!contextMenuState.visible) return;
      if (!els.contextMenu || els.contextMenu.contains(e.target)) return;
      hideContextMenu();
    });

    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        hideContextMenu();
      }
    });

    function drawGrid() {
      const w = els.view.clientWidth, h = els.view.clientHeight;
      ctx.save();
      ctx.translate(scrollX, scrollY);
      ctx.scale(zoom, zoom);
      ctx.clearRect(-scrollX/zoom, -scrollY/zoom, w/zoom, h/zoom);

      // D√©grad√© de ciel dynamique
      const g = ctx.createLinearGradient(0, -scrollY/zoom - 500, 0, h/zoom - scrollY/zoom + 500);
      g.addColorStop(0, '#87ceeb');
      g.addColorStop(0.3, '#b8e6ff');
      g.addColorStop(0.7, '#e0f6ff');
      g.addColorStop(1, '#98fb98');
      ctx.fillStyle = g;
      ctx.fillRect(-scrollX/zoom - 1000, -scrollY/zoom - 1000, w/zoom + 2000, h/zoom + 2000);
      const step = 50;
      const viewLeft = -scrollX/zoom - 100;
      const viewRight = viewLeft + w/zoom + 200;
      const viewTop = -scrollY/zoom - 100;
      const viewBottom = viewTop + h/zoom + 200;

      // Lignes verticales (avec lignes majeures tous les 250px)
      const startX = Math.floor(viewLeft / step) * step;
      for (let x = startX; x <= viewRight; x += step) {
        const major = x % 250 === 0;
        ctx.strokeStyle = major ? 'rgba(183, 211, 255, 0.8)' : 'rgba(215, 234, 255, 0.5)';
        ctx.lineWidth = major ? 1.5 : 0.8;
        ctx.beginPath();
        ctx.moveTo(x, viewTop);
        ctx.lineTo(x, viewBottom);
        ctx.stroke();
      }

      // Lignes horizontales (avec lignes majeures tous les 250px)
      const startY = Math.floor(viewTop / step) * step;
      for (let y = startY; y <= viewBottom; y += step) {
        const major = y % 250 === 0;
        ctx.strokeStyle = major ? 'rgba(183, 211, 255, 0.8)' : 'rgba(215, 234, 255, 0.5)';
        ctx.lineWidth = major ? 1.5 : 0.8;
        ctx.beginPath();
        ctx.moveTo(viewLeft, y);
        ctx.lineTo(viewRight, y);
        ctx.stroke();
      }

      // Axes de coordonn√©es (0,0)
      ctx.strokeStyle = 'rgba(255, 100, 100, 0.7)';
      ctx.lineWidth = 2;
      // Axe X
      ctx.beginPath();
      ctx.moveTo(viewLeft, 0);
      ctx.lineTo(viewRight, 0);
      ctx.stroke();
      // Axe Y
      ctx.beginPath();
      ctx.moveTo(0, viewTop);
      ctx.lineTo(0, viewBottom);
      ctx.stroke();
      ctx.restore();
    }

    function draw() {
      const w = els.view.clientWidth, h = els.view.clientHeight;
      ctx.clearRect(0, 0, w, h);
      drawGrid();
      const lvl = data.levels[current];
      ctx.save();
      ctx.translate(scrollX, scrollY);
      ctx.scale(zoom, zoom);

      // Ground avec d√©grad√©
      const groundGradient = ctx.createLinearGradient(0, lvl.ground.y, 0, lvl.ground.y + 100);
      groundGradient.addColorStop(0, '#3d8b3d');
      groundGradient.addColorStop(0.3, '#2e8b57');
      groundGradient.addColorStop(1, '#1e5e3e');
      ctx.fillStyle = groundGradient;
      ctx.fillRect(lvl.ground.start_x, lvl.ground.y, lvl.ground.end_x - lvl.ground.start_x, 100);
      ctx.strokeStyle = '#1b5e3b';
      ctx.lineWidth = 3;
      ctx.strokeRect(lvl.ground.start_x, lvl.ground.y, Math.max(1, lvl.ground.end_x - lvl.ground.start_x), 100);

      // Platforms avec d√©grad√© et ombres
      lvl.platforms.forEach(p => {
        // Ombre
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(p.x + 3, p.y + 3, p.w, p.h);

        // Plateforme avec d√©grad√©
        const platformGradient = ctx.createLinearGradient(0, p.y, 0, p.y + p.h);
        platformGradient.addColorStop(0, '#8b7355');
        platformGradient.addColorStop(0.5, '#654321');
        platformGradient.addColorStop(1, '#4a2c17');
        ctx.fillStyle = platformGradient;
        ctx.fillRect(p.x, p.y, p.w, p.h);

        // Bordure
        ctx.strokeStyle = '#8b5a2b';
        ctx.lineWidth = 2;
        ctx.strokeRect(p.x, p.y, p.w, p.h);

        // Highlight sur le dessus
        ctx.strokeStyle = 'rgba(139, 115, 85, 0.8)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x + p.w, p.y);
        ctx.stroke();
      });

      // Enemies
      if (lvl.enemies && lvl.enemies.length) {
        lvl.enemies.forEach(en => {
          const t = en.type || 'basic';
          const colors = {
            basic: ['#dc2626', '#7f1d1d'],
            patrol: ['#f97316', '#7c2d12'],
            shooter: ['#7c3aed', '#4c1d95'],
            flyer: ['#2563eb', '#1e3a8a']
          };
          const [fillC, strokeC] = colors[t] || colors.basic;
          ctx.fillStyle = fillC;
          ctx.strokeStyle = strokeC;
          ctx.lineWidth = 2;
          ctx.fillRect(en.x, en.y, en.w, en.h);
          ctx.strokeRect(en.x, en.y, en.w, en.h);
          // yeux
          ctx.fillStyle = '#fff';
          ctx.fillRect(en.x + 6, en.y + 8, 4, 6);
          ctx.fillRect(en.x + en.w - 10, en.y + 8, 4, 6);
          // label type
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.font = '12px ui-monospace, monospace';
          ctx.fillText(t, en.x, en.y - 6);
        });
      }

      // Goal (porte) avec effet brillant
      // Ombre
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(lvl.goal.x + 4, lvl.goal.y + 4, lvl.goal.w, lvl.goal.h);

      // Porte avec d√©grad√© dor√©
      const goalGradient = ctx.createLinearGradient(0, lvl.goal.y, 0, lvl.goal.y + lvl.goal.h);
      goalGradient.addColorStop(0, '#ffd700');
      goalGradient.addColorStop(0.3, '#b8860b');
      goalGradient.addColorStop(0.7, '#b8860b');
      goalGradient.addColorStop(1, '#8b6508');
      ctx.fillStyle = goalGradient;
      ctx.fillRect(lvl.goal.x, lvl.goal.y, lvl.goal.w, lvl.goal.h);

      // Bordure dor√©e
      ctx.strokeStyle = '#8b6508';
      ctx.lineWidth = 3;
      ctx.strokeRect(lvl.goal.x, lvl.goal.y, lvl.goal.w, lvl.goal.h);

      // Poign√©e de porte
      ctx.fillStyle = '#654321';
      ctx.beginPath();
      ctx.arc(lvl.goal.x + lvl.goal.w * 0.8, lvl.goal.y + lvl.goal.h * 0.5, 4, 0, Math.PI * 2);
      ctx.fill();

      // Label avec fond
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(lvl.goal.x - 5, lvl.goal.y - 25, 50, 16);
      ctx.fillStyle = '#ffd700';
      ctx.font = 'bold 12px ui-monospace, monospace';
      ctx.fillText('üö™ Porte', lvl.goal.x, lvl.goal.y - 10);

      // Spawn avec effet pulsant
      const time = Date.now() / 1000;
      const pulse = 0.8 + 0.2 * Math.sin(time * 3);

      // Cercles concentriques
      for (let i = 3; i >= 0; i--) {
        const alpha = (1 - i * 0.2) * 0.3;
        ctx.fillStyle = `rgba(31, 111, 235, ${alpha})`;
        ctx.beginPath();
        ctx.arc(lvl.spawn.x, lvl.spawn.y, (18 + i * 8) * pulse, 0, Math.PI * 2);
        ctx.fill();
      }

      // Spawn principal
      const spawnGradient = ctx.createRadialGradient(lvl.spawn.x, lvl.spawn.y, 0, lvl.spawn.x, lvl.spawn.y, 12);
      spawnGradient.addColorStop(0, '#4fc3f7');
      spawnGradient.addColorStop(0.7, '#1f6feb');
      spawnGradient.addColorStop(1, '#0d47a1');
      ctx.fillStyle = spawnGradient;
      ctx.beginPath();
      ctx.arc(lvl.spawn.x, lvl.spawn.y, 12 * pulse, 0, Math.PI * 2);
      ctx.fill();

      // Bordure
      ctx.strokeStyle = '#0d47a1';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(lvl.spawn.x, lvl.spawn.y, 12 * pulse, 0, Math.PI * 2);
      ctx.stroke();

      // Label avec fond
      ctx.fillStyle = 'rgba(13, 71, 161, 0.9)';
      ctx.fillRect(lvl.spawn.x + 15, lvl.spawn.y - 12, 55, 16);
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 12px ui-monospace, monospace';
      ctx.fillText('üéØ Spawn', lvl.spawn.x + 18, lvl.spawn.y - 2);

      ctx.restore();
    }

    // Init
    refreshLevelSelect();
    renderForm();
    resize();
    draw();
    // Mouse world coordinates display
    els.view.addEventListener('mousemove', (e) => {
      const rect = els.view.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (els.view.width / rect.width);
      const y = (e.clientY - rect.top) * (els.view.height / rect.height);
      let px = Math.round((x - scrollX) / zoom);
      let py = Math.round((y - scrollY) / zoom);
      px = doSnap(px); py = doSnap(py);
      const z = Math.round(zoom * 100) / 100;
      const el = document.getElementById('mouseInfo');
      if (el) el.textContent = `| Souris: ${px}, ${py} | Zoom: ${z}x`;
    });
  </script>
</body>
</html>
