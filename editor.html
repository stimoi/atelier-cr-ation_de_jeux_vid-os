<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>√âditeur de niveaux</title>
  <style>
    * { box-sizing: border-box; }
    body { 
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; 
      margin: 0; 
      display: grid; 
      grid-template-columns: 380px 1fr; 
      height: 100vh; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      overflow: hidden;
    }
    header { 
      grid-column: 1 / -1; 
      padding: 16px 20px; 
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); 
      color: #fff; 
      display: flex; 
      align-items: center; 
      gap: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      border-bottom: 2px solid rgba(255,255,255,0.1);
    }
    header h1 { 
      font-size: 22px; 
      margin: 0; 
      font-weight: 600;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .sidebar { 
      overflow: auto; 
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(10px);
      border-right: 2px solid rgba(255,255,255,0.2); 
      padding: 20px; 
      display: flex; 
      flex-direction: column; 
      gap: 20px;
      box-shadow: 4px 0 20px rgba(0,0,0,0.1);
    }
    .sidebar::-webkit-scrollbar { width: 8px; }
    .sidebar::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); border-radius: 4px; }
    .sidebar::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 4px; }
    .sidebar::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.3); }
    .section { 
      border: 2px solid rgba(102, 126, 234, 0.2); 
      border-radius: 16px; 
      padding: 18px; 
      background: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
      box-shadow: 0 8px 25px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.8);
      transition: all 0.3s ease;
    }
    .section:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 35px rgba(0,0,0,0.12), inset 0 1px 0 rgba(255,255,255,0.9);
      border-color: rgba(102, 126, 234, 0.4);
    }
    .section h2 { 
      margin: 0 0 12px 0; 
      font-size: 18px; 
      font-weight: 600;
      color: #1e3a8a;
      text-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    label { 
      display: block; 
      font-size: 13px; 
      color: #374151; 
      margin-top: 10px; 
      font-weight: 500;
    }
    input[type="number"], input[type="text"], select { 
      width: 100%; 
      box-sizing: border-box; 
      padding: 10px 12px; 
      margin-top: 6px;
      border: 2px solid #e5e7eb;
      border-radius: 10px;
      font-size: 14px;
      transition: all 0.2s ease;
      background: #ffffff;
    }
    input[type="number"]:focus, input[type="text"]:focus, select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      transform: translateY(-1px);
    }
    button { 
      padding: 10px 16px; 
      border-radius: 10px; 
      border: 2px solid transparent; 
      background: linear-gradient(145deg, #f8fafc 0%, #e2e8f0 100%); 
      cursor: pointer;
      font-weight: 500;
      font-size: 14px;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }
    button.primary { 
      background: linear-gradient(145deg, #667eea 0%, #764ba2 100%); 
      color: white; 
      border-color: transparent;
    }
    button.primary:hover {
      background: linear-gradient(145deg, #5a67d8 0%, #6b46c1 100%);
    }
    button.danger { 
      background: linear-gradient(145deg, #f56565 0%, #e53e3e 100%); 
      color: white; 
      border-color: transparent;
    }
    button.danger:hover {
      background: linear-gradient(145deg, #e53e3e 0%, #c53030 100%);
    }
    .row { display: flex; gap: 10px; align-items: center; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .platforms { 
      display: flex; 
      flex-direction: column; 
      gap: 10px; 
      max-height: 280px; 
      overflow: auto;
      padding: 8px;
      background: rgba(0,0,0,0.02);
      border-radius: 8px;
    }
    .platforms::-webkit-scrollbar { width: 6px; }
    .platforms::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); border-radius: 3px; }
    .platforms::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 3px; }
    .platform { 
      display: grid; 
      grid-template-columns: repeat(4, 1fr) 40px; 
      gap: 8px; 
      padding: 8px;
      background: rgba(255,255,255,0.8);
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,0.1);
    }
    .canvas-wrap { 
      position: relative; 
      height: calc(100vh - 80px); 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      overflow: hidden;
    }
    canvas { 
      width: 100%; 
      height: 100%; 
      display: block; 
      background: linear-gradient(180deg, #87ceeb 0%, #e0f6ff 50%, #98fb98 100%);
      cursor: crosshair;
    }
    .toolbar { 
      position: absolute; 
      top: 16px; 
      left: 16px; 
      display: flex; 
      gap: 12px; 
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(10px);
      padding: 12px 16px; 
      border-radius: 16px; 
      box-shadow: 0 8px 25px rgba(0,0,0,0.15);
      border: 2px solid rgba(255,255,255,0.3);
    }
    .navigation-help {
      position: absolute;
      bottom: 16px;
      left: 16px;
      background: rgba(30, 60, 114, 0.9);
      color: white;
      padding: 12px 16px;
      border-radius: 12px;
      font-size: 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    small.mono { 
      font-family: 'SF Mono', ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; 
      color: #64748b; 
      font-size: 12px;
    }
    .tag { 
      padding: 4px 8px; 
      border-radius: 20px; 
      font-size: 11px; 
      font-weight: 600;
      border: 1px solid transparent;
    }
    .tag.enemy { 
      background: linear-gradient(145deg, #fee2e2 0%, #fecaca 100%); 
      color: #991b1b; 
      border-color: #fca5a5;
    }
    .list-headers { 
      display: grid; 
      gap: 8px; 
      font-size: 12px; 
      color: #6b7280; 
      padding: 0 4px;
      font-weight: 600;
    }
    .list-headers.platform { grid-template-columns: repeat(4, 1fr) 40px; }
    .list-headers.enemy { grid-template-columns: repeat(4, 1fr) 1fr 40px; }
    .list-headers span { font-weight: 700; }
    .enemy-type { 
      display: inline-block; 
      width: 70px; 
      text-align: center;
      padding: 2px 6px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 600;
    }
    .enemy-type.basic { background: linear-gradient(145deg, #fee2e2 0%, #fecaca 100%); color: #991b1b; }
    .enemy-type.patrol { background: linear-gradient(145deg, #fed7aa 0%, #fdba74 100%); color: #9a3412; }
    .enemy-type.shooter { background: linear-gradient(145deg, #dcfce7 0%, #bbf7d0 100%); color: #166534; }
    .enemy-type.flyer { background: linear-gradient(145deg, #e0e7ff 0%, #c7d2fe 100%); color: #3730a3; }
  </style>
</head>
<body>
  <header>
    <h1>√âditeur de niveaux</h1>
    <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
      <input type="file" id="importFile" accept="application/json" />
      <button class="primary" id="exportBtn">Exporter levels.json</button>
    </div>
  </header>

  <div class="sidebar">
    <div class="section">
      <h2>Niveaux</h2>
      <div class="row">
        <select id="levelSelect" style="flex:1"></select>
        <button id="addLevelBtn">Ajouter</button>
        <button class="danger" id="deleteLevelBtn">Supprimer</button>
      </div>
      <label>Nom</label>
      <input type="text" id="levelName" placeholder="Nom du niveau" />
    </div>

    <div class="section">
      <h2>Sol</h2>
      <div class="grid-2">
        <div>
          <label>Y</label>
          <input type="number" id="groundY" />
        </div>
        <div>
          <label>D√©but X</label>
          <input type="number" id="groundStart" />
        </div>
        <div>
          <label>Fin X</label>
          <input type="number" id="groundEnd" />
        </div>
      </div>
    </div>

    <div class="section">
      <h2>Spawn</h2>
      <div class="grid-2">
        <div>
          <label>X</label>
          <input type="number" id="spawnX" />
        </div>
        <div>
          <label>Y</label>
          <input type="number" id="spawnY" />
        </div>
      </div>
      <label>Position de d√©part</label>
    </div>

    <div class="section">
      <h2>But (porte)</h2>
      <div class="grid-2">
        <div>
          <label>X</label>
          <input type="number" id="goalX" />
        </div>
        <div>
          <label>Y</label>
          <input type="number" id="goalY" />
        </div>
        <div>
          <label>Largeur</label>
          <input type="number" id="goalW" />
        </div>
        <div>
          <label>Hauteur</label>
          <input type="number" id="goalH" />
        </div>
      </div>
      <label>Position de la porte</label>
    </div>

    <div class="section">
      <h2>Plateformes</h2>
      <div class="list-headers platform">
        <span>X</span>
        <span>Y</span>
        <span>Largeur</span>
        <span>Hauteur</span>
        <span></span>
      </div>
      <div class="platforms" id="platformList"></div>
      <button id="addPlatformBtn">+ Ajouter une plateforme</button>
      <small class="mono">Astuce: cliquez dans la pr√©visualisation pour ajouter rapidement (100x20).</small>
    </div>

    <div class="section">
      <h2>Ennemis <span class="tag enemy">danger</span></h2>
      <div class="list-headers enemy">
        <span>X</span>
        <span>Y</span>
        <span>Largeur</span>
        <span>Hauteur</span>
        <span>Type</span>
        <span></span>
      </div>
      <div class="platforms" id="enemyList"></div>
      <button id="addEnemyBtn">+ Ajouter un ennemi</button>
      <small class="mono">Conseil: placez-les au-dessus du sol et des plateformes.</small>
    </div>
  </div>

  <div class="canvas-wrap">
    <div class="toolbar">
      <small class="mono">üéÆ Navigation: Fl√®ches ou WASD</small>
      <small class="mono">üîç Zoom: Ctrl + molette</small>
      <small class="mono" id="mouseInfo"></small>
      <label class="mono" style="display:flex;align-items:center;gap:6px;margin-left:8px;">
        <input type="checkbox" id="snapToggle" checked>
        Snap
      </label>
      <label class="mono" style="display:flex;align-items:center;gap:6px;">
        Pas
        <input type="number" id="snapStep" value="10" min="1" style="width:64px;">
      </label>
    </div>
    <div class="navigation-help">
      <div><strong>üöÄ Navigation Infinie</strong></div>
      <div>‚Ä¢ Fl√®ches / WASD: D√©placer la vue</div>
      <div>‚Ä¢ Molette: Zoom</div>
      <div>‚Ä¢ Clic milieu + glisser: Panoramique</div>
      <div>‚Ä¢ Clic gauche: Ajouter/d√©placer</div>
      <div>‚Ä¢ Clic droit: Supprimer</div>
    </div>
    <canvas id="view"></canvas>
  </div>

  <script>
    const DEFAULT_LEVEL = {
      name: 'Niveau 1',
      ground: { y: 680, start_x: 0, end_x: 3000 },
      spawn: { x: 683, y: 590 },
      goal: { x: 2300, y: -30, w: 70, h: 110 },
      platforms: [
        { x: 100, y: 560, w: 200, h: 20 },
        { x: 380, y: 480, w: 180, h: 20 },
        { x: 620, y: 420, w: 160, h: 20 },
        { x: 860, y: 360, w: 140, h: 20 },
        { x: 1060, y: 300, w: 180, h: 20 },
        { x: 1300, y: 200, w: 250, h: 20 },
        { x: 1600, y: 600, w: 100, h: 20 },
        { x: 1750, y: 500, w: 100, h: 20 },
        { x: 1600, y: 400, w: 100, h: 20 },
        { x: 1750, y: 300, w: 100, h: 20 },
        { x: 1600, y: 200, w: 100, h: 20 },
        { x: 1750, y: 100, w: 100, h: 20 },
        { x: 1900, y: 60,  w: 500, h: 20 }
      ],
      enemies: [
        { x: 500, y: 640, w: 28, h: 28, type: 'basic' },
      ]
    };

    let data = { levels: [ structuredClone(DEFAULT_LEVEL) ] };
    let current = 0;

    const els = {
      levelSelect: document.getElementById('levelSelect'),
      levelName: document.getElementById('levelName'),
      groundY: document.getElementById('groundY'),
      groundStart: document.getElementById('groundStart'),
      groundEnd: document.getElementById('groundEnd'),
      spawnX: document.getElementById('spawnX'),
      spawnY: document.getElementById('spawnY'),
      goalX: document.getElementById('goalX'),
      goalY: document.getElementById('goalY'),
      goalW: document.getElementById('goalW'),
      goalH: document.getElementById('goalH'),
      platformList: document.getElementById('platformList'),
      enemyList: document.getElementById('enemyList'),
      addPlatformBtn: document.getElementById('addPlatformBtn'),
      addEnemyBtn: document.getElementById('addEnemyBtn'),
      addLevelBtn: document.getElementById('addLevelBtn'),
      deleteLevelBtn: document.getElementById('deleteLevelBtn'),
      exportBtn: document.getElementById('exportBtn'),
      importFile: document.getElementById('importFile'),
      view: document.getElementById('view')
    };

    function refreshLevelSelect() {
      els.levelSelect.innerHTML = '';
      data.levels.forEach((lvl, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = `${i+1}. ${lvl.name || 'Sans nom'}`;
        els.levelSelect.appendChild(opt);
      });
      els.levelSelect.value = String(current);
    }

    function bindValue(input, getter, setter) {
      input.value = getter();
      input.oninput = () => { setter(Number.isFinite(+input.value) ? +input.value : input.value); draw(); };
    }

    function renderForm() {
      const lvl = data.levels[current];
      els.levelName.value = lvl.name || '';
      bindValue(els.groundY, () => lvl.ground.y, v => lvl.ground.y = v);
      bindValue(els.groundStart, () => lvl.ground.start_x, v => lvl.ground.start_x = v);
      bindValue(els.groundEnd, () => lvl.ground.end_x, v => lvl.ground.end_x = v);
      bindValue(els.spawnX, () => lvl.spawn.x, v => lvl.spawn.x = v);
      bindValue(els.spawnY, () => lvl.spawn.y, v => lvl.spawn.y = v);
      bindValue(els.goalX, () => lvl.goal.x, v => lvl.goal.x = v);
      bindValue(els.goalY, () => lvl.goal.y, v => lvl.goal.y = v);
      bindValue(els.goalW, () => lvl.goal.w, v => lvl.goal.w = v);
      bindValue(els.goalH, () => lvl.goal.h, v => lvl.goal.h = v);

      els.levelName.oninput = () => { lvl.name = els.levelName.value; refreshLevelSelect(); };

      els.platformList.innerHTML = '';
      lvl.platforms.forEach((p, idx) => {
        const row = document.createElement('div');
        row.className = 'platform';
        row.innerHTML = `
          <input type="number" value="${p.x}" />
          <input type="number" value="${p.y}" />
          <input type="number" value="${p.w}" />
          <input type="number" value="${p.h}" />
          <button data-idx="${idx}">√É‚Äî</button>
        `;
        const [x,y,w,h,btn] = row.querySelectorAll('input,button');
        x.oninput = () => { p.x = +x.value; draw(); };
        y.oninput = () => { p.y = +y.value; draw(); };
        w.oninput = () => { p.w = +w.value; draw(); };
        h.oninput = () => { p.h = +h.value; draw(); };
        btn.onclick = () => { lvl.platforms.splice(idx,1); renderForm(); draw(); };
        els.platformList.appendChild(row);
      });

      els.enemyList.innerHTML = '';
      (lvl.enemies || (lvl.enemies = [])).forEach((en, idx) => {
        const row = document.createElement('div');
        row.className = 'platform';
        row.style.gridTemplateColumns = 'repeat(4, 1fr) 1fr 32px';
        row.innerHTML = `
          <input type="number" value="${en.x}" />
          <input type="number" value="${en.y}" />
          <input type="number" value="${en.w}" />
          <input type="number" value="${en.h}" />
          <select>
            <option value="basic">basic</option>
            <option value="patrol">patrol</option>
            <option value="shooter">shooter</option>
            <option value="flyer">flyer</option>
          </select>
          <button data-idx="${idx}">√É‚Äî</button>
        `;
        const inputs = row.querySelectorAll('input,select,button');
        const x = inputs[0];
        const y = inputs[1];
        const w = inputs[2];
        const h = inputs[3];
        const typeSel = inputs[4];
        const btn = inputs[5];
        x.oninput = () => { en.x = +x.value; draw(); };
        y.oninput = () => { en.y = +y.value; draw(); };
        w.oninput = () => { en.w = +w.value; draw(); };
        h.oninput = () => { en.h = +h.value; draw(); };
        typeSel.value = en.type || 'basic';
        typeSel.onchange = () => { en.type = typeSel.value; draw(); };
        btn.onclick = () => { lvl.enemies.splice(idx,1); renderForm(); draw(); };
        els.enemyList.appendChild(row);
      });
    }

    els.addPlatformBtn.onclick = () => {
      data.levels[current].platforms.push({ x: 100, y: 100, w: 100, h: 20 });
      renderForm();
      draw();
    };

    els.addEnemyBtn.onclick = () => {
      (data.levels[current].enemies || (data.levels[current].enemies = [])).push({ x: 200, y: 640, w: 28, h: 28, type: 'basic' });
      renderForm();
      draw();
    };

    els.addLevelBtn.onclick = () => {
      data.levels.push(structuredClone(DEFAULT_LEVEL));
      current = data.levels.length - 1;
      refreshLevelSelect();
      renderForm();
      draw();
    };

    els.deleteLevelBtn.onclick = () => {
      if (data.levels.length <= 1) return;
      data.levels.splice(current, 1);
      current = Math.max(0, current - 1);
      refreshLevelSelect();
      renderForm();
      draw();
    };

    els.levelSelect.onchange = () => {
      current = +els.levelSelect.value;
      renderForm();
      draw();
    };

    els.exportBtn.onclick = () => {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'levels.json';
      a.click();
      URL.revokeObjectURL(a.href);
    };

    els.importFile.onchange = async () => {
      const file = els.importFile.files?.[0];
      if (!file) return;
      const text = await file.text();
      try {
        const json = JSON.parse(text);
        if (!json.levels || !Array.isArray(json.levels)) throw new Error('levels[] manquant');
        data = json;
        current = 0;
        refreshLevelSelect();
        renderForm();
        draw();
      } catch (e) {
        alert('Fichier invalide: ' + e.message);
      } finally {
        els.importFile.value = '';
      }
    };

    // Canvas preview
    const ctx = els.view.getContext('2d');
    let zoom = 1;
    let scrollX = 0, scrollY = 0;
    let dragging = null; // { type: 'platform'|'goal'|'spawn'|'pan', idx?: number, dx, dy }

    // Navigation infinie avec le clavier
    const keys = {};
    const MOVE_SPEED = 200; // pixels par seconde
    let lastTime = 0;

    // Gestion des touches
    window.addEventListener('keydown', (e) => {
      // Emp√™cher le d√©filement de la page
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyA', 'KeyS', 'KeyD'].includes(e.code)) {
        e.preventDefault();
      }
      keys[e.code] = true;
    });

    window.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });

    // Boucle d'animation pour la navigation fluide
    function updateNavigation(currentTime) {
      if (lastTime === 0) lastTime = currentTime;
      const deltaTime = (currentTime - lastTime) / 1000; // en secondes
      lastTime = currentTime;

      let moved = false;
      const moveDistance = MOVE_SPEED * deltaTime;

      // Navigation avec les fl√®ches ou WASD
      if (keys['ArrowLeft'] || keys['KeyA']) {
        scrollX += moveDistance;
        moved = true;
      }
      if (keys['ArrowRight'] || keys['KeyD']) {
        scrollX -= moveDistance;
        moved = true;
      }
      if (keys['ArrowUp'] || keys['KeyW']) {
        scrollY += moveDistance;
        moved = true;
      }
      if (keys['ArrowDown'] || keys['KeyS']) {
        scrollY -= moveDistance;
        moved = true;
      }

      if (moved) {
        draw();
      }

      requestAnimationFrame(updateNavigation);
    }

    // D√©marrer la boucle d'animation
    requestAnimationFrame(updateNavigation);

    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      els.view.width = Math.floor(els.view.clientWidth * dpr);
      els.view.height = Math.floor(els.view.clientHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      draw();
    }
    window.addEventListener('resize', resize);

    els.view.addEventListener('wheel', (e) => {
      if (e.ctrlKey) {
        // Zoom avec Ctrl + molette
        e.preventDefault();
        const delta = Math.sign(e.deltaY);
        const rect = els.view.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Zoom centr√© sur la souris
        const worldX = (mouseX - scrollX) / zoom;
        const worldY = (mouseY - scrollY) / zoom;

        const newZoom = Math.min(5, Math.max(0.1, zoom * (delta > 0 ? 0.9 : 1.1)));

        scrollX = mouseX - worldX * newZoom;
        scrollY = mouseY - worldY * newZoom;
        zoom = newZoom;

        draw();
      } else {
        // D√©placement vertical avec la molette normale
        e.preventDefault();
        scrollY += e.deltaY * 0.5;
        draw();
      }
    }, { passive: false });

    function worldFromClient(e) {
      const rect = els.view.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (els.view.width / rect.width);
      const y = (e.clientY - rect.top) * (els.view.height / rect.height);
      const px = (x - scrollX) / zoom;
      const py = (y - scrollY) / zoom;
      return { px, py };
    }

    function doSnap(v) {
      const stepEl = document.getElementById('snapStep');
      const toggleEl = document.getElementById('snapToggle');
      const step = Math.max(1, +(stepEl?.value || 10));
      const use = !!(toggleEl?.checked);
      return use ? Math.round(v / step) * step : v;
    }

    function hitTest(lvl, x, y) {
      // Test plateformes en priorit√© (haut->bas)
      for (let i = lvl.platforms.length - 1; i >= 0; i--) {
        const p = lvl.platforms[i];
        if (x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h) {
          return { type: 'platform', idx: i };
        }
      }
      // Porte
      const g = lvl.goal;
      if (x >= g.x && x <= g.x + g.w && y >= g.y && y <= g.y + g.h) return { type: 'goal' };
      // Spawn (cercle rayon ~12)
      const dx = x - lvl.spawn.x, dy = y - lvl.spawn.y;
      if (dx*dx + dy*dy <= 12*12) return { type: 'spawn' };
      return null;
    }

    els.view.addEventListener('mousedown', (e) => {
      const btn = e.button; // 0: gauche, 1: milieu, 2: droit
      const lvl = data.levels[current];
      const { px, py } = worldFromClient(e);
      if (btn === 1) {
        dragging = { type: 'pan', dx: e.clientX, dy: e.clientY };
        return;
      }
      if (btn === 2) {
        // clic droit: delete plateforme sous la souris
        const hit = hitTest(lvl, px, py);
        if (hit?.type === 'platform') {
          lvl.platforms.splice(hit.idx, 1);
          renderForm();
          draw();
        }
        return;
      }
      // gauche: drag objet ou ajout si vide
      const hit = hitTest(lvl, px, py);
      if (hit) {
        if (hit.type === 'platform') {
          const p = lvl.platforms[hit.idx];
          dragging = { type: 'platform', idx: hit.idx, dx: px - p.x, dy: py - p.y };
        } else if (hit.type === 'goal') {
          dragging = { type: 'goal', dx: px - lvl.goal.x, dy: py - lvl.goal.y };
        } else if (hit.type === 'spawn') {
          dragging = { type: 'spawn', dx: px - lvl.spawn.x, dy: py - lvl.spawn.y };
        }
      } else {
        // ajout rapide si vide
        const nx = doSnap(Math.round(px));
        const ny = doSnap(Math.round(py));
        lvl.platforms.push({ x: nx, y: ny, w: 100, h: 20 });
        renderForm();
        draw();
      }
    });

    window.addEventListener('mouseup', () => { dragging = null; });

    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const lvl = data.levels[current];
      if (dragging.type === 'pan') {
        scrollX += (e.clientX - dragging.dx);
        scrollY += (e.clientY - dragging.dy);
        dragging.dx = e.clientX; dragging.dy = e.clientY;
        draw();
        return;
      }
      const { px, py } = worldFromClient(e);
      if (dragging.type === 'platform') {
        const p = lvl.platforms[dragging.idx];
        p.x = doSnap(px - dragging.dx);
        p.y = doSnap(py - dragging.dy);
      } else if (dragging.type === 'goal') {
        lvl.goal.x = doSnap(px - dragging.dx);
        lvl.goal.y = doSnap(py - dragging.dy);
      } else if (dragging.type === 'spawn') {
        lvl.spawn.x = doSnap(px - dragging.dx);
        lvl.spawn.y = doSnap(py - dragging.dy);
      }
      renderForm();
      draw();
    });

    function drawGrid() {
      const w = els.view.clientWidth, h = els.view.clientHeight;
      ctx.save();
      ctx.translate(scrollX, scrollY);
      ctx.scale(zoom, zoom);
      ctx.clearRect(-scrollX/zoom, -scrollY/zoom, w/zoom, h/zoom);

      // D√©grad√© de ciel dynamique
      const g = ctx.createLinearGradient(0, -scrollY/zoom - 500, 0, h/zoom - scrollY/zoom + 500);
      g.addColorStop(0, '#87ceeb');
      g.addColorStop(0.3, '#b8e6ff');
      g.addColorStop(0.7, '#e0f6ff');
      g.addColorStop(1, '#98fb98');
      ctx.fillStyle = g;
      ctx.fillRect(-scrollX/zoom - 1000, -scrollY/zoom - 1000, w/zoom + 2000, h/zoom + 2000);
      const step = 50;
      const viewLeft = -scrollX/zoom - 100;
      const viewRight = viewLeft + w/zoom + 200;
      const viewTop = -scrollY/zoom - 100;
      const viewBottom = viewTop + h/zoom + 200;

      // Lignes verticales (avec lignes majeures tous les 250px)
      const startX = Math.floor(viewLeft / step) * step;
      for (let x = startX; x <= viewRight; x += step) {
        const major = x % 250 === 0;
        ctx.strokeStyle = major ? 'rgba(183, 211, 255, 0.8)' : 'rgba(215, 234, 255, 0.5)';
        ctx.lineWidth = major ? 1.5 : 0.8;
        ctx.beginPath();
        ctx.moveTo(x, viewTop);
        ctx.lineTo(x, viewBottom);
        ctx.stroke();
      }

      // Lignes horizontales (avec lignes majeures tous les 250px)
      const startY = Math.floor(viewTop / step) * step;
      for (let y = startY; y <= viewBottom; y += step) {
        const major = y % 250 === 0;
        ctx.strokeStyle = major ? 'rgba(183, 211, 255, 0.8)' : 'rgba(215, 234, 255, 0.5)';
        ctx.lineWidth = major ? 1.5 : 0.8;
        ctx.beginPath();
        ctx.moveTo(viewLeft, y);
        ctx.lineTo(viewRight, y);
        ctx.stroke();
      }

      // Axes de coordonn√©es (0,0)
      ctx.strokeStyle = 'rgba(255, 100, 100, 0.7)';
      ctx.lineWidth = 2;
      // Axe X
      ctx.beginPath();
      ctx.moveTo(viewLeft, 0);
      ctx.lineTo(viewRight, 0);
      ctx.stroke();
      // Axe Y
      ctx.beginPath();
      ctx.moveTo(0, viewTop);
      ctx.lineTo(0, viewBottom);
      ctx.stroke();
      ctx.restore();
    }

    function draw() {
      const w = els.view.clientWidth, h = els.view.clientHeight;
      ctx.clearRect(0, 0, w, h);
      drawGrid();
      const lvl = data.levels[current];
      ctx.save();
      ctx.translate(scrollX, scrollY);
      ctx.scale(zoom, zoom);

      // Ground avec d√©grad√©
      const groundGradient = ctx.createLinearGradient(0, lvl.ground.y, 0, lvl.ground.y + 100);
      groundGradient.addColorStop(0, '#3d8b3d');
      groundGradient.addColorStop(0.3, '#2e8b57');
      groundGradient.addColorStop(1, '#1e5e3e');
      ctx.fillStyle = groundGradient;
      ctx.fillRect(lvl.ground.start_x, lvl.ground.y, lvl.ground.end_x - lvl.ground.start_x, 100);
      ctx.strokeStyle = '#1b5e3b';
      ctx.lineWidth = 3;
      ctx.strokeRect(lvl.ground.start_x, lvl.ground.y, Math.max(1, lvl.ground.end_x - lvl.ground.start_x), 100);

      // Platforms avec d√©grad√© et ombres
      lvl.platforms.forEach(p => {
        // Ombre
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(p.x + 3, p.y + 3, p.w, p.h);

        // Plateforme avec d√©grad√©
        const platformGradient = ctx.createLinearGradient(0, p.y, 0, p.y + p.h);
        platformGradient.addColorStop(0, '#8b7355');
        platformGradient.addColorStop(0.5, '#654321');
        platformGradient.addColorStop(1, '#4a2c17');
        ctx.fillStyle = platformGradient;
        ctx.fillRect(p.x, p.y, p.w, p.h);

        // Bordure
        ctx.strokeStyle = '#8b5a2b';
        ctx.lineWidth = 2;
        ctx.strokeRect(p.x, p.y, p.w, p.h);

        // Highlight sur le dessus
        ctx.strokeStyle = 'rgba(139, 115, 85, 0.8)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x + p.w, p.y);
        ctx.stroke();
      });

      // Enemies
      if (lvl.enemies && lvl.enemies.length) {
        lvl.enemies.forEach(en => {
          const t = en.type || 'basic';
          const colors = {
            basic: ['#dc2626', '#7f1d1d'],
            patrol: ['#f97316', '#7c2d12'],
            shooter: ['#7c3aed', '#4c1d95'],
            flyer: ['#2563eb', '#1e3a8a']
          };
          const [fillC, strokeC] = colors[t] || colors.basic;
          ctx.fillStyle = fillC;
          ctx.strokeStyle = strokeC;
          ctx.lineWidth = 2;
          ctx.fillRect(en.x, en.y, en.w, en.h);
          ctx.strokeRect(en.x, en.y, en.w, en.h);
          // yeux
          ctx.fillStyle = '#fff';
          ctx.fillRect(en.x + 6, en.y + 8, 4, 6);
          ctx.fillRect(en.x + en.w - 10, en.y + 8, 4, 6);
          // label type
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.font = '12px ui-monospace, monospace';
          ctx.fillText(t, en.x, en.y - 6);
        });
      }

      // Goal (porte) avec effet brillant
      // Ombre
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(lvl.goal.x + 4, lvl.goal.y + 4, lvl.goal.w, lvl.goal.h);

      // Porte avec d√©grad√© dor√©
      const goalGradient = ctx.createLinearGradient(0, lvl.goal.y, 0, lvl.goal.y + lvl.goal.h);
      goalGradient.addColorStop(0, '#ffd700');
      goalGradient.addColorStop(0.3, '#b8860b');
      goalGradient.addColorStop(0.7, '#b8860b');
      goalGradient.addColorStop(1, '#8b6508');
      ctx.fillStyle = goalGradient;
      ctx.fillRect(lvl.goal.x, lvl.goal.y, lvl.goal.w, lvl.goal.h);

      // Bordure dor√©e
      ctx.strokeStyle = '#8b6508';
      ctx.lineWidth = 3;
      ctx.strokeRect(lvl.goal.x, lvl.goal.y, lvl.goal.w, lvl.goal.h);

      // Poign√©e de porte
      ctx.fillStyle = '#654321';
      ctx.beginPath();
      ctx.arc(lvl.goal.x + lvl.goal.w * 0.8, lvl.goal.y + lvl.goal.h * 0.5, 4, 0, Math.PI * 2);
      ctx.fill();

      // Label avec fond
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(lvl.goal.x - 5, lvl.goal.y - 25, 50, 16);
      ctx.fillStyle = '#ffd700';
      ctx.font = 'bold 12px ui-monospace, monospace';
      ctx.fillText('üö™ Porte', lvl.goal.x, lvl.goal.y - 10);

      // Spawn avec effet pulsant
      const time = Date.now() / 1000;
      const pulse = 0.8 + 0.2 * Math.sin(time * 3);

      // Cercles concentriques
      for (let i = 3; i >= 0; i--) {
        const alpha = (1 - i * 0.2) * 0.3;
        ctx.fillStyle = `rgba(31, 111, 235, ${alpha})`;
        ctx.beginPath();
        ctx.arc(lvl.spawn.x, lvl.spawn.y, (18 + i * 8) * pulse, 0, Math.PI * 2);
        ctx.fill();
      }

      // Spawn principal
      const spawnGradient = ctx.createRadialGradient(lvl.spawn.x, lvl.spawn.y, 0, lvl.spawn.x, lvl.spawn.y, 12);
      spawnGradient.addColorStop(0, '#4fc3f7');
      spawnGradient.addColorStop(0.7, '#1f6feb');
      spawnGradient.addColorStop(1, '#0d47a1');
      ctx.fillStyle = spawnGradient;
      ctx.beginPath();
      ctx.arc(lvl.spawn.x, lvl.spawn.y, 12 * pulse, 0, Math.PI * 2);
      ctx.fill();

      // Bordure
      ctx.strokeStyle = '#0d47a1';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(lvl.spawn.x, lvl.spawn.y, 12 * pulse, 0, Math.PI * 2);
      ctx.stroke();

      // Label avec fond
      ctx.fillStyle = 'rgba(13, 71, 161, 0.9)';
      ctx.fillRect(lvl.spawn.x + 15, lvl.spawn.y - 12, 55, 16);
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 12px ui-monospace, monospace';
      ctx.fillText('üéØ Spawn', lvl.spawn.x + 18, lvl.spawn.y - 2);

      ctx.restore();
    }

    // Init
    refreshLevelSelect();
    renderForm();
    resize();
    draw();
    // Mouse world coordinates display
    els.view.addEventListener('mousemove', (e) => {
      const rect = els.view.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (els.view.width / rect.width);
      const y = (e.clientY - rect.top) * (els.view.height / rect.height);
      let px = Math.round((x - scrollX) / zoom);
      let py = Math.round((y - scrollY) / zoom);
      px = doSnap(px); py = doSnap(py);
      const z = Math.round(zoom * 100) / 100;
      const el = document.getElementById('mouseInfo');
      if (el) el.textContent = `| Souris: ${px}, ${py} | Zoom: ${z}x`;
    });
  </script>
</body>
</html>
